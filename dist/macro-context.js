'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.wrapInTerms=wrapInTerms;var _errors=require('./errors'),_immutable=require('immutable'),_enforester=require('./enforester'),_syntax=require('./syntax'),_syntax2=_interopRequireDefault(_syntax),_ramda=require('ramda'),_=_interopRequireWildcard(_ramda),_scopeReducer=require('./scope-reducer'),_scopeReducer2=_interopRequireDefault(_scopeReducer),_sweetSpec=require('sweet-spec'),T=_interopRequireWildcard(_sweetSpec),S=_interopRequireWildcard(_sweetSpec);function _interopRequireWildcard(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);return b.default=a,b}function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function wrapInTerms(a){return a.map(b=>{if(b.isTemplate())b.token.items=b.token.items.map(c=>{return c instanceof _syntax2.default?wrapInTerms(_immutable.List.of(c)).first():c});else if(b.isParens()||b.isBraces()||b.isBrackets()||b.isSyntaxTemplate())return new S.RawDelimiter({kind:b.isBraces()?'braces':b.isParens()?'parens':b.isBrackets()?'brackets':'syntaxTemplate',inner:wrapInTerms(b.token)});return new S.RawSyntax({value:b})})}const privateData=new WeakMap;function cloneEnforester(a){const{rest:b,prev:c,context:d}=a;return new _enforester.Enforester(b,c,d)}function Marker(){}class MacroContext{constructor(a,b,c,d,e){const f=new Marker,g=cloneEnforester(a),h={name:b,context:c,enf:g,startMarker:f,markers:new Map([[f,a]])};d&&e?(h.noScopes=!1,h.useScope=d,h.introducedScope=e):h.noScopes=!0,privateData.set(this,h),this.reset(),this[Symbol.iterator]=()=>this}name(){const{name:a}=privateData.get(this);return a}contextify(a){if(!(a instanceof T.RawDelimiter))throw new Error(`Can only contextify a delimiter but got ${a}`);const{context:b}=privateData.get(this);let c=new _enforester.Enforester(a.inner.slice(1,a.inner.size-1),(0,_immutable.List)(),b);return new MacroContext(c,'inner',b)}expand(a){const{enf:b}=privateData.get(this);if(0===b.rest.size)return{done:!0,value:null};b.expandMacro();let c=b.rest,d;switch(a){case'AssignmentExpression':case'expr':d=b.enforestExpressionLoop();break;case'Expression':d=b.enforestExpression();break;case'Statement':case'stmt':d=b.enforestStatement();break;case'BlockStatement':case'WhileStatement':case'IfStatement':case'ForStatement':case'SwitchStatement':case'BreakStatement':case'ContinueStatement':case'DebuggerStatement':case'WithStatement':case'TryStatement':case'ThrowStatement':case'ClassDeclaration':case'FunctionDeclaration':case'LabeledStatement':case'VariableDeclarationStatement':case'ReturnStatement':case'ExpressionStatement':d=b.enforestStatement(),(0,_errors.expect)(_.whereEq({type:a},d),`Expecting a ${a}`,d,c);break;case'YieldExpression':d=b.enforestYieldExpression();break;case'ClassExpression':d=b.enforestClass({isExpr:!0});break;case'ArrowExpression':d=b.enforestArrowExpression();break;case'NewExpression':d=b.enforestNewExpression();break;case'ThisExpression':case'FunctionExpression':case'IdentifierExpression':case'LiteralNumericExpression':case'LiteralInfinityExpression':case'LiteralStringExpression':case'TemplateExpression':case'LiteralBooleanExpression':case'LiteralNullExpression':case'LiteralRegExpExpression':case'ObjectExpression':case'ArrayExpression':d=b.enforestPrimaryExpression();break;case'UnaryExpression':case'UpdateExpression':case'BinaryExpression':case'StaticMemberExpression':case'ComputedMemberExpression':case'CompoundAssignmentExpression':case'ConditionalExpression':d=b.enforestExpressionLoop(),(0,_errors.expect)(_.whereEq({type:a},d),`Expecting a ${a}`,d,c);break;default:throw new Error('Unknown term type: '+a);}return{done:!1,value:d}}_rest(a){const b=privateData.get(this);if(b.markers.get(b.startMarker)===a)return b.enf.rest;throw Error('Unauthorized access!')}reset(a){const b=privateData.get(this);let c;if(null==a)c=b.markers.get(b.startMarker);else if(!(a&&a instanceof Marker))throw new Error('marker must be an instance of Marker');else if(b.markers.has(a))c=b.markers.get(a);else throw new Error('marker must originate from this context');b.enf=cloneEnforester(c)}mark(){const a=privateData.get(this);let b;return a.enf.rest===a.markers.get(a.startMarker).rest?b=a.startMarker:a.enf.rest.isEmpty()?(!a.endMarker&&(a.endMarker=new Marker),b=a.endMarker):b=new Marker,a.markers.has(b)||a.markers.set(b,cloneEnforester(a.enf)),b}next(){const{enf:a,noScopes:b,useScope:c,introducedScope:d,context:e}=privateData.get(this);if(0===a.rest.size)return{done:!0,value:null};let f=a.advance();return b||(f=f.reduce(new _scopeReducer2.default([{scope:c,phase:_syntax.ALL_PHASES,flip:!1},{scope:d,phase:_syntax.ALL_PHASES,flip:!0}],e.bindings))),{done:!1,value:f}}}exports.default=MacroContext;

