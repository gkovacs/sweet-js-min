"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Modules=exports.Module=void 0;var _immutable=require("immutable"),_env=require("./env"),_env2=_interopRequireDefault(_env),_store=require("./store"),_store2=_interopRequireDefault(_store),_shiftReader=require("./shift-reader"),_shiftReader2=_interopRequireDefault(_shiftReader),_ramda=require("ramda"),_=_interopRequireWildcard(_ramda),_symbol=require("./symbol"),_terms=require("./terms"),T=_interopRequireWildcard(_terms),_loadSyntax=require("./load-syntax"),_compiler=require("./compiler"),_compiler2=_interopRequireDefault(_compiler),_transforms=require("./transforms"),_scope=require("./scope"),_errors=require("./errors"),_hygieneUtils=require("./hygiene-utils"),_syntax=require("./syntax");function _interopRequireWildcard(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);return b.default=a,b}function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}class Module{constructor(a,b,c,d,e,f){this.moduleSpecifier=a,this.isNative=b,this.importEntries=c,this.exportEntries=d,this.pragmas=e,this.body=f}}exports.Module=Module;const findBindingIdentifierName=a=>{return(0,_errors.assert)(a.name,`not implemented yet for type ${a.type}`),a.name},convertExport=a=>{let b=a.declaration,c=[];T.isVariableDeclaration(b)?c=b.declarators.map(e=>findBindingIdentifierName(e.binding)):(T.isFunctionDeclaration(b)||T.isClassDeclaration(b))&&c.push(findBindingIdentifierName(b.name));let d=c.map(e=>{return new T.default("ExportSpecifier",{name:null,exportedName:e})});return new T.default("ExportFrom",{moduleSpecifier:null,namedExports:(0,_immutable.List)(d)})},pragmaRegep=/^\s*#\w*/;class Modules{constructor(a){this.compiledModules=new Map,this.context=a,this.context.modules=this}loadString(a){let b=1>=arguments.length||arguments[1]===void 0||arguments[1],c=pragmaRegep.test(a);return b&&!c?{isNative:!0,body:(0,_immutable.List)()}:{isNative:!c,body:new _shiftReader2.default(a).read()}}load(a){return this.loadString(this.context.moduleLoader(a))}compile(a,b){let c=a.body,d=(0,_scope.freshScope)("outsideEdge"),e=(0,_scope.freshScope)(`insideEdge0`),f=new _compiler2.default(0,new _env2.default(),new _store2.default(),_.merge(this.context,{currentScope:[d,e],cwd:"<<entrypoint>>"===b?this.context.cwd:(0,_utilsDirname2.default)(b)})),g=f.compile(c.map(l=>l.addScope(d,this.context.bindings,_syntax.ALL_PHASES).addScope(e,this.context.bindings,0))),h=[],i=[],j=[],k=g.reduce((l,m)=>{return _.cond([[T.isImport,n=>{return h.push(n),l}],[T.isExport,n=>{return n.declaration?(i.push(convertExport(n)),T.isVariableDeclaration(n.declaration)?l.concat(new T.default("VariableDeclarationStatement",{declaration:n.declaration})):l.concat(n.declaration)):(i.push(n),l)}],[T.isPragma,n=>{return j.push(n),l}],[_.T,n=>l.concat(n)]])(m)},(0,_immutable.List)());return new Module(b,a.isNative,(0,_immutable.List)(h),(0,_immutable.List)(i),(0,_immutable.List)(j),k)}compileEntrypoint(a,b){let c=2>=arguments.length||arguments[2]===void 0?!1:arguments[2],d=this.loadString(a,!1);if(c&&d.isNative)throw new Error(`Entrypoint ${b} must begin with #lang pragma`);return this.getAtPhase("<<entrypoint>>",0,this.context.cwd,d)}getAtPhase(a,b,c){let d=3>=arguments.length||arguments[3]===void 0?null:arguments[3],e="<<entrypoint>>"===a?a:this.context.moduleResolver(a,c),f=`${e}:${b}`;if(!this.compiledModules.has(f))if(0===b){let g=null==d?this.load(e):d;this.compiledModules.set(f,this.compile(g,e))}else{let g=this.getAtPhase(a,0,c,d),h=(0,_scope.freshScope)(`insideEdge${b}`);this.compiledModules.set(f,new Module(g.moduleSpecifier,!1,g.importEntries.map(i=>i.addScope(h,this.context.bindings,b)),g.exportEntries.map(i=>i.addScope(h,this.context.bindings,b)),g.pragmas,g.body.map(i=>i.addScope(h,this.context.bindings,b))))}return this.compiledModules.get(f)}has(a){let b=1>=arguments.length||arguments[1]===void 0?0:arguments[1],c="<<entrypoint>>"===a?a:this.context.moduleResolver(a,this.context.cwd),d=`${c}:${b}`;return this.compiledModules.has(d)&&!this.compiledModules.get(d).isNative}registerSyntaxDeclaration(a,b,c){a.declarators.forEach(d=>{let e=(0,_loadSyntax.evalCompiletimeValue)(d.init.gen(),_.merge(this.context,{phase:b+1,store:c}));(0,_hygieneUtils.collectBindings)(d.binding).forEach(f=>{if(0!==b){let h=(0,_symbol.gensym)(f.val());this.context.bindings.add(f,{binding:h,phase:b,skipDup:!1})}let g=f.resolve(b);c.set(g,new _transforms.CompiletimeTransform(e))})})}registerVariableDeclaration(a,b,c){a.declarators.forEach(d=>{(0,_hygieneUtils.collectBindings)(d.binding).forEach(e=>{if(0!==b){let g=(0,_symbol.gensym)(e.val());this.context.bindings.add(e,{binding:g,phase:b,skipDup:"var"===a.kind})}let f=e.resolve(b);c.set(f,new _transforms.VarBindingTransform(e))})})}registerFunctionOrClass(a,b,c){(0,_hygieneUtils.collectBindings)(a.name).forEach(d=>{if(0!==b){let f=(0,_symbol.gensym)(d.val());this.context.bindings.add(d,{binding:f,phase:b,skipDup:!1})}let e=d.resolve(b);c.set(e,new _transforms.VarBindingTransform(d))})}visit(a,b,c){return a.body.forEach(d=>{T.isSyntaxDeclarationStatement(d)&&this.registerSyntaxDeclaration(d.declaration,b,c)}),c}invoke(a,b,c){let d=a.body.filter(_.complement(T.isCompiletimeStatement)).map(e=>{return e=e.gen(),T.isVariableDeclarationStatement(e)?this.registerVariableDeclaration(e.declaration,b,c):T.isFunctionDeclaration(e)&&this.registerFunctionOrClass(e,b,c),e});return(0,_loadSyntax.evalRuntimeValues)(d,_.merge(this.context,{store:c,phase:b})),c}}exports.Modules=Modules;

