"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ALL_PHASES=exports.Types=void 0;var _immutable=require("immutable"),_errors=require("./errors"),_bindingMap=require("./binding-map"),_bindingMap2=_interopRequireDefault(_bindingMap),_ramdaFantasy=require("ramda-fantasy"),_ramda=require("ramda"),_=_interopRequireWildcard(_ramda),_tokenizer=require("shift-parser/dist/tokenizer");function _interopRequireWildcard(c){if(c&&c.__esModule)return c;var d={};if(null!=c)for(var e in c)Object.prototype.hasOwnProperty.call(c,e)&&(d[e]=c[e]);return d.default=c,d}function _interopRequireDefault(c){return c&&c.__esModule?c:{default:c}}function getFirstSlice(c){return c&&"function"==typeof c.isDelimiter?c.isDelimiter()?c.token.get(0).token.slice:c.token.slice:null}function sizeDecending(c,d){return c.scopes.size>d.scopes.size?-1:d.scopes.size>c.scopes.size?1:0}let Types=exports.Types={null:{match:c=>!Types.delimiter.match(c)&&c.type===_tokenizer.TokenType.NULL,create:(c,d)=>new Syntax({type:_tokenizer.TokenType.NULL,value:null},d)},number:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.NumericLiteral,create:(c,d)=>new Syntax({type:_tokenizer.TokenType.NUMBER,value:c},d)},string:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.StringLiteral,create:(c,d)=>new Syntax({type:_tokenizer.TokenType.STRING,str:c},d)},punctuator:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.Punctuator,create:(c,d)=>new Syntax({type:{klass:_tokenizer.TokenClass.Punctuator,name:c},value:c},d)},keyword:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.Keyword,create:(c,d)=>new Syntax({type:{klass:_tokenizer.TokenClass.Keyword,name:c},value:c},d)},identifier:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.Ident,create:(c,d)=>new Syntax({type:_tokenizer.TokenType.IDENTIFIER,value:c},d)},regularExpression:{match:c=>!Types.delimiter.match(c)&&c.type.klass===_tokenizer.TokenClass.RegularExpression,create:(c,d)=>new Syntax({type:_tokenizer.TokenType.REGEXP,value:c},d)},braces:{match:c=>Types.delimiter.match(c)&&c.get(0).token.type===_tokenizer.TokenType.LBRACE,create:(c,d)=>{let e=new Syntax({type:_tokenizer.TokenType.LBRACE,value:"{",slice:getFirstSlice(d)}),f=new Syntax({type:_tokenizer.TokenType.RBRACE,value:"}",slice:getFirstSlice(d)});return new Syntax(_immutable.List.of(e).concat(c).push(f),d)}},brackets:{match:c=>Types.delimiter.match(c)&&c.get(0).token.type===_tokenizer.TokenType.LBRACK,create:(c,d)=>{let e=new Syntax({type:_tokenizer.TokenType.LBRACK,value:"[",slice:getFirstSlice(d)}),f=new Syntax({type:_tokenizer.TokenType.RBRACK,value:"]",slice:getFirstSlice(d)});return new Syntax(_immutable.List.of(e).concat(c).push(f),d)}},parens:{match:c=>Types.delimiter.match(c)&&c.get(0).token.type===_tokenizer.TokenType.LPAREN,create:(c,d)=>{let e=new Syntax({type:_tokenizer.TokenType.LPAREN,value:"(",slice:getFirstSlice(d)}),f=new Syntax({type:_tokenizer.TokenType.RPAREN,value:")",slice:getFirstSlice(d)});return new Syntax(_immutable.List.of(e).concat(c).push(f),d)}},assign:{match:c=>{if(Types.punctuator.match(c))switch(c.value){case"=":case"|=":case"^=":case"&=":case"<<=":case">>=":case">>>=":case"+=":case"-=":case"*=":case"/=":case"%=":return!0;default:return!1;}return!1}},boolean:{match:c=>!Types.delimiter.match(c)&&c.type===_tokenizer.TokenType.TRUE||c.type===_tokenizer.TokenType.FALSE},template:{match:c=>!Types.delimiter.match(c)&&c.type===_tokenizer.TokenType.TEMPLATE},delimiter:{match:c=>_immutable.List.isList(c)},syntaxTemplate:{match:c=>Types.delimiter.match(c)&&"#`"===c.get(0).val()},eof:{match:c=>!Types.delimiter.match(c)&&c.type===_tokenizer.TokenType.EOS}};const ALL_PHASES=exports.ALL_PHASES={};class Syntax{constructor(c,d){this.token=c,this.bindings=d&&null!=d.bindings?d.bindings:new _bindingMap2.default,this.scopesets=d&&null!=d.scopesets?d.scopesets:{all:(0,_immutable.List)(),phase:(0,_immutable.Map)()},Object.freeze(this)}static of(c,d){return new Syntax(c,d)}static from(c,d,e){if(!Types[c])throw new Error(c+" is not a valid type");else if(!Types[c].create)throw new Error("Cannot create a syntax from type "+c);let f=Types[c].create(d,e),g=getFirstSlice(e);return null!=g&&(f.token.slice=g),f}from(c,d){return Syntax.from(c,d,this)}fromNull(){return this.from("null",null)}fromNumber(c){return this.from("number",c)}fromString(c){return this.from("string",c)}fromPunctuator(c){return this.from("punctuator",c)}fromKeyword(c){return this.from("keyword",c)}fromIdentifier(c){return this.from("identifier",c)}fromRegularExpression(c){return this.from("regularExpression",c)}fromBraces(c){return this.from("braces",c)}fromBrackets(c){return this.from("brackets",c)}fromParens(c){return this.from("parens",c)}static fromNull(c){return Syntax.from("null",null,c)}static fromNumber(c,d){return Syntax.from("number",c,d)}static fromString(c,d){return Syntax.from("string",c,d)}static fromPunctuator(c,d){return Syntax.from("punctuator",c,d)}static fromKeyword(c,d){return Syntax.from("keyword",c,d)}static fromIdentifier(c,d){return Syntax.from("identifier",c,d)}static fromRegularExpression(c,d){return Syntax.from("regularExpression",c,d)}static fromBraces(c,d){return Syntax.from("braces",c,d)}static fromBrackets(c,d){return Syntax.from("brackets",c,d)}static fromParens(c,d){return Syntax.from("parens",c,d)}resolve(c){(0,_errors.assert)(null!=c,"must provide a phase to resolve");let d=this.scopesets.all,e=this.scopesets.phase.has(c)?this.scopesets.phase.get(c):(0,_immutable.List)();if(e=d.concat(e),0===e.size||!(this.match("identifier")||this.match("keyword")))return this.token.value;let f=e.last(),g=this.bindings;if(f){let h=g.get(this);if(h){let i=h.filter(j=>{let k=j.scopes;return k.isSubset(e)}).sort(sizeDecending);if(2<=i.size&&i.get(0).scopes.size===i.get(1).scopes.size){let j="{"+e.map(l=>l.toString()).join(", ")+"}",k=i.map(l=>{let m=l.scopes;return"{"+m.map(n=>n.toString()).join(", ")+"}"}).join(", ");throw new Error("Scopeset "+j+" has ambiguous subsets "+k)}else if(0!==i.size){let j=i.get(0).binding.toString();return _ramdaFantasy.Maybe.isJust(i.get(0).alias)?i.get(0).alias.getOrElse(null).resolve(c):j}}}return this.token.value}val(){return(0,_errors.assert)(!this.match("delimiter"),"cannot get the val of a delimiter"),this.match("string")?this.token.str:this.match("template")?this.token.items.map(c=>{return"function"==typeof c.match&&c.match("delimiter")?"${...}":c.slice.text}).join(""):this.token.value}lineNumber(){return this.match("delimiter")?this.token.get(0).lineNumber():this.token.slice.startLocation.line}setLineNumber(c){let d={};if(this.isDelimiter())d=this.token.map(e=>e.setLineNumber(c));else{for(let e of Object.keys(this.token))d[e]=this.token[e];(0,_errors.assert)(d.slice&&d.slice.startLocation,"all tokens must have line info"),d.slice.startLocation.line=c}return new Syntax(d,this)}inner(){return(0,_errors.assert)(this.match("delimiter"),"can only get the inner of a delimiter"),this.token.slice(1,this.token.size-1)}addScope(c,d,e){let f=3>=arguments.length||void 0===arguments[3]?{flip:!1}:arguments[3],g=this.match("delimiter")?this.token.map(k=>k.addScope(c,d,e,f)):this.token;this.match("template")&&(g=_.merge(g,{items:g.items.map(k=>{return k instanceof Syntax&&k.match("delimiter")?k.addScope(c,d,e,f):k})}));let h=e===ALL_PHASES?this.scopesets.all:this.scopesets.phase.has(e)?this.scopesets.phase.get(e):(0,_immutable.List)();let i;if(f.flip){let k=h.indexOf(c);i=-1===k?h.push(c):h.remove(k)}else i=h.push(c);let j={bindings:d,scopesets:{all:this.scopesets.all,phase:this.scopesets.phase}};return e===ALL_PHASES?j.scopesets.all=i:j.scopesets.phase=j.scopesets.phase.set(e,i),new Syntax(g,j)}removeScope(c,d){let e=this.match("delimiter")?this.token.map(k=>k.removeScope(c,d)):this.token,f=this.scopesets.phase.has(d)?this.scopesets.phase.get(d):(0,_immutable.List)(),g=this.scopesets.all,h={bindings:this.bindings,scopesets:{all:this.scopesets.all,phase:this.scopesets.phase}},i=f.indexOf(c),j=g.indexOf(c);return-1===i?-1!==j&&(h.scopesets.all=g.remove(j)):h.scopesets.phase=this.scopesets.phase.set(d,f.remove(i)),new Syntax(e,h)}match(c,d){if(!Types[c])throw new Error(c+" is an invalid type");return Types[c].match(this.token)&&(null==d||(d instanceof RegExp?d.test(this.val()):this.val()==d))}isIdentifier(c){return this.match("identifier",c)}isAssign(c){return this.match("assign",c)}isBooleanLiteral(c){return this.match("boolean",c)}isKeyword(c){return this.match("keyword",c)}isNullLiteral(c){return this.match("null",c)}isNumericLiteral(c){return this.match("number",c)}isPunctuator(c){return this.match("punctuator",c)}isStringLiteral(c){return this.match("string",c)}isRegularExpression(c){return this.match("regularExpression",c)}isTemplate(c){return this.match("template",c)}isDelimiter(c){return this.match("delimiter",c)}isParens(c){return this.match("parens",c)}isBraces(c){return this.match("braces",c)}isBrackets(c){return this.match("brackets",c)}isSyntaxTemplate(c){return this.match("syntaxTemplate",c)}isEOF(c){return this.match("eof",c)}toString(){return this.match("delimiter")?this.token.map(c=>c.toString()).join(" "):this.match("string")?"'"+this.token.str:this.match("template")?this.val():this.token.value}}exports.default=Syntax;

