'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = require('immutable');

var _errors = require('./errors');

var _ramdaFantasy = require('ramda-fantasy');

var _syntax = require('./syntax');

var _syntax2 = _interopRequireDefault(_syntax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BindingMap {

  constructor() {
    this._map = new Map();
  }

  // given a syntax object and a binding,
  // add the binding to the map associating the binding with the syntax object's
  // scope set
  add(stx, { binding, phase, skipDup = false }) {
    let stxName = stx.val();
    let allScopeset = stx.scopesets.all;
    let scopeset = stx.scopesets.phase.has(phase) ? stx.scopesets.phase.get(phase) : (0, _immutable.List)();
    scopeset = allScopeset.concat(scopeset);
    (0, _errors.assert)(phase != null, 'must provide a phase for binding add');

    let scopesetBindingList = this._map.get(stxName);
    if (scopesetBindingList) {
      if (skipDup && scopesetBindingList.some(s => s.scopes.equals(scopeset))) {
        return;
      }
      this._map.set(stxName, scopesetBindingList.push({
        scopes: scopeset,
        binding: binding,
        alias: _ramdaFantasy.Maybe.Nothing()
      }));
    } else {
      this._map.set(stxName, _immutable.List.of({
        scopes: scopeset,
        binding: binding,
        alias: _ramdaFantasy.Maybe.Nothing()
      }));
    }
  }

  addForward(stx, forwardStx, binding, phase) {
    let stxName = stx.token.value;
    let allScopeset = stx.scopesets.all;
    let scopeset = stx.scopesets.phase.has(phase) ? stx.scopesets.phase.get(phase) : (0, _immutable.List)();
    scopeset = allScopeset.concat(scopeset);
    (0, _errors.assert)(phase != null, 'must provide a phase for binding add');

    let scopesetBindingList = this._map.get(stxName);
    if (scopesetBindingList) {
      this._map.set(stxName, scopesetBindingList.push({
        scopes: scopeset,
        binding: binding,
        alias: _ramdaFantasy.Maybe.of(forwardStx)
      }));
    } else {
      this._map.set(stxName, _immutable.List.of({
        scopes: scopeset,
        binding: binding,
        alias: _ramdaFantasy.Maybe.of(forwardStx)
      }));
    }
  }

  get(stx) {
    return this._map.get(stx.token.value);
  }
}
exports.default = BindingMap;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaW5kaW5nLW1hcC5qcyJdLCJuYW1lcyI6WyJCaW5kaW5nTWFwIiwiY29uc3RydWN0b3IiLCJfbWFwIiwiTWFwIiwiYWRkIiwic3R4IiwiYmluZGluZyIsInBoYXNlIiwic2tpcER1cCIsInN0eE5hbWUiLCJ2YWwiLCJhbGxTY29wZXNldCIsInNjb3Blc2V0cyIsImFsbCIsInNjb3Blc2V0IiwiaGFzIiwiZ2V0IiwiY29uY2F0Iiwic2NvcGVzZXRCaW5kaW5nTGlzdCIsInNvbWUiLCJzIiwic2NvcGVzIiwiZXF1YWxzIiwic2V0IiwicHVzaCIsImFsaWFzIiwiTm90aGluZyIsIm9mIiwiYWRkRm9yd2FyZCIsImZvcndhcmRTdHgiLCJ0b2tlbiIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7O0FBVWUsTUFBTUEsVUFBTixDQUFpQjs7QUFHOUJDLGdCQUFjO0FBQ1osU0FBS0MsSUFBTCxHQUFZLElBQUlDLEdBQUosRUFBWjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBQyxNQUFJQyxHQUFKLEVBQWlCLEVBQUVDLE9BQUYsRUFBV0MsS0FBWCxFQUFrQkMsVUFBVSxLQUE1QixFQUFqQixFQUFxSDtBQUNuSCxRQUFJQyxVQUFVSixJQUFJSyxHQUFKLEVBQWQ7QUFDQSxRQUFJQyxjQUFjTixJQUFJTyxTQUFKLENBQWNDLEdBQWhDO0FBQ0EsUUFBSUMsV0FBV1QsSUFBSU8sU0FBSixDQUFjTCxLQUFkLENBQW9CUSxHQUFwQixDQUF3QlIsS0FBeEIsSUFBaUNGLElBQUlPLFNBQUosQ0FBY0wsS0FBZCxDQUFvQlMsR0FBcEIsQ0FBd0JULEtBQXhCLENBQWpDLEdBQWtFLHNCQUFqRjtBQUNBTyxlQUFXSCxZQUFZTSxNQUFaLENBQW1CSCxRQUFuQixDQUFYO0FBQ0Esd0JBQU9QLFNBQVMsSUFBaEIsRUFBc0Isc0NBQXRCOztBQUVBLFFBQUlXLHNCQUFzQixLQUFLaEIsSUFBTCxDQUFVYyxHQUFWLENBQWNQLE9BQWQsQ0FBMUI7QUFDQSxRQUFJUyxtQkFBSixFQUF5QjtBQUN2QixVQUFJVixXQUFXVSxvQkFBb0JDLElBQXBCLENBQXlCQyxLQUFLQSxFQUFFQyxNQUFGLENBQVNDLE1BQVQsQ0FBZ0JSLFFBQWhCLENBQTlCLENBQWYsRUFBeUU7QUFDdkU7QUFDRDtBQUNELFdBQUtaLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QlMsb0JBQW9CTSxJQUFwQixDQUF5QjtBQUM5Q0gsZ0JBQVFQLFFBRHNDO0FBRTlDUixpQkFBU0EsT0FGcUM7QUFHOUNtQixlQUFPLG9CQUFNQyxPQUFOO0FBSHVDLE9BQXpCLENBQXZCO0FBS0QsS0FURCxNQVNPO0FBQ0wsV0FBS3hCLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QixnQkFBS2tCLEVBQUwsQ0FBUTtBQUM3Qk4sZ0JBQVFQLFFBRHFCO0FBRTdCUixpQkFBU0EsT0FGb0I7QUFHN0JtQixlQUFPLG9CQUFNQyxPQUFOO0FBSHNCLE9BQVIsQ0FBdkI7QUFLRDtBQUNGOztBQUVERSxhQUFXdkIsR0FBWCxFQUF3QndCLFVBQXhCLEVBQTRDdkIsT0FBNUMsRUFBa0VDLEtBQWxFLEVBQXNGO0FBQ3BGLFFBQUlFLFVBQVVKLElBQUl5QixLQUFKLENBQVVDLEtBQXhCO0FBQ0EsUUFBSXBCLGNBQWNOLElBQUlPLFNBQUosQ0FBY0MsR0FBaEM7QUFDQSxRQUFJQyxXQUFXVCxJQUFJTyxTQUFKLENBQWNMLEtBQWQsQ0FBb0JRLEdBQXBCLENBQXdCUixLQUF4QixJQUFpQ0YsSUFBSU8sU0FBSixDQUFjTCxLQUFkLENBQW9CUyxHQUFwQixDQUF3QlQsS0FBeEIsQ0FBakMsR0FBa0Usc0JBQWpGO0FBQ0FPLGVBQVdILFlBQVlNLE1BQVosQ0FBbUJILFFBQW5CLENBQVg7QUFDQSx3QkFBT1AsU0FBUyxJQUFoQixFQUFzQixzQ0FBdEI7O0FBRUEsUUFBSVcsc0JBQXNCLEtBQUtoQixJQUFMLENBQVVjLEdBQVYsQ0FBY1AsT0FBZCxDQUExQjtBQUNBLFFBQUlTLG1CQUFKLEVBQXlCO0FBQ3ZCLFdBQUtoQixJQUFMLENBQVVxQixHQUFWLENBQWNkLE9BQWQsRUFBdUJTLG9CQUFvQk0sSUFBcEIsQ0FBeUI7QUFDOUNILGdCQUFRUCxRQURzQztBQUU5Q1IsaUJBQVNBLE9BRnFDO0FBRzlDbUIsZUFBTyxvQkFBTUUsRUFBTixDQUFTRSxVQUFUO0FBSHVDLE9BQXpCLENBQXZCO0FBS0QsS0FORCxNQU1PO0FBQ0wsV0FBSzNCLElBQUwsQ0FBVXFCLEdBQVYsQ0FBY2QsT0FBZCxFQUF1QixnQkFBS2tCLEVBQUwsQ0FBUTtBQUM3Qk4sZ0JBQVFQLFFBRHFCO0FBRTdCUixpQkFBU0EsT0FGb0I7QUFHN0JtQixlQUFPLG9CQUFNRSxFQUFOLENBQVNFLFVBQVQ7QUFIc0IsT0FBUixDQUF2QjtBQUtEO0FBRUY7O0FBRURiLE1BQUlYLEdBQUosRUFBaUI7QUFDZixXQUFPLEtBQUtILElBQUwsQ0FBVWMsR0FBVixDQUFjWCxJQUFJeUIsS0FBSixDQUFVQyxLQUF4QixDQUFQO0FBQ0Q7QUE5RDZCO2tCQUFYL0IsVSIsImZpbGUiOiJiaW5kaW5nLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAncmFtZGEtZmFudGFzeSc7XG5pbXBvcnQgdHlwZSB7IFN5bWJvbENsYXNzIH0gZnJvbSAnLi9zeW1ib2wnO1xuaW1wb3J0IFN5bnRheCBmcm9tICcuL3N5bnRheCc7XG5cbnR5cGUgU2NvcGVzZXQgPSBhbnk7XG5cbnR5cGUgU2NvcGVzZXRCaW5kaW5nID0ge1xuICBzY29wZXM6IFNjb3Blc2V0O1xuICBiaW5kaW5nOiBTeW1ib2xDbGFzcztcbiAgYWxpYXM6IE1heWJlPFN5bnRheD5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmluZGluZ01hcCB7XG4gIF9tYXA6IE1hcDxzdHJpbmcsIExpc3Q8U2NvcGVzZXRCaW5kaW5nPj47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLy8gZ2l2ZW4gYSBzeW50YXggb2JqZWN0IGFuZCBhIGJpbmRpbmcsXG4gIC8vIGFkZCB0aGUgYmluZGluZyB0byB0aGUgbWFwIGFzc29jaWF0aW5nIHRoZSBiaW5kaW5nIHdpdGggdGhlIHN5bnRheCBvYmplY3Qnc1xuICAvLyBzY29wZSBzZXRcbiAgYWRkKHN0eDogU3ludGF4LCB7IGJpbmRpbmcsIHBoYXNlLCBza2lwRHVwID0gZmFsc2UgfTogeyBiaW5kaW5nOiBTeW1ib2xDbGFzcywgcGhhc2U6IG51bWJlciB8IHt9LCBza2lwRHVwOiBib29sZWFufSkge1xuICAgIGxldCBzdHhOYW1lID0gc3R4LnZhbCgpO1xuICAgIGxldCBhbGxTY29wZXNldCA9IHN0eC5zY29wZXNldHMuYWxsO1xuICAgIGxldCBzY29wZXNldCA9IHN0eC5zY29wZXNldHMucGhhc2UuaGFzKHBoYXNlKSA/IHN0eC5zY29wZXNldHMucGhhc2UuZ2V0KHBoYXNlKSA6IExpc3QoKTtcbiAgICBzY29wZXNldCA9IGFsbFNjb3Blc2V0LmNvbmNhdChzY29wZXNldCk7XG4gICAgYXNzZXJ0KHBoYXNlICE9IG51bGwsICdtdXN0IHByb3ZpZGUgYSBwaGFzZSBmb3IgYmluZGluZyBhZGQnKTtcblxuICAgIGxldCBzY29wZXNldEJpbmRpbmdMaXN0ID0gdGhpcy5fbWFwLmdldChzdHhOYW1lKTtcbiAgICBpZiAoc2NvcGVzZXRCaW5kaW5nTGlzdCkge1xuICAgICAgaWYgKHNraXBEdXAgJiYgc2NvcGVzZXRCaW5kaW5nTGlzdC5zb21lKHMgPT4gcy5zY29wZXMuZXF1YWxzKHNjb3Blc2V0KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwLnNldChzdHhOYW1lLCBzY29wZXNldEJpbmRpbmdMaXN0LnB1c2goe1xuICAgICAgICBzY29wZXM6IHNjb3Blc2V0LFxuICAgICAgICBiaW5kaW5nOiBiaW5kaW5nLFxuICAgICAgICBhbGlhczogTWF5YmUuTm90aGluZygpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgTGlzdC5vZih7XG4gICAgICAgIHNjb3Blczogc2NvcGVzZXQsXG4gICAgICAgIGJpbmRpbmc6IGJpbmRpbmcsXG4gICAgICAgIGFsaWFzOiBNYXliZS5Ob3RoaW5nKClcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICBhZGRGb3J3YXJkKHN0eDogU3ludGF4LCBmb3J3YXJkU3R4OiBTeW50YXgsIGJpbmRpbmc6IFN5bWJvbENsYXNzLCBwaGFzZTogbnVtYmVyIHwge30pIHtcbiAgICBsZXQgc3R4TmFtZSA9IHN0eC50b2tlbi52YWx1ZTtcbiAgICBsZXQgYWxsU2NvcGVzZXQgPSBzdHguc2NvcGVzZXRzLmFsbDtcbiAgICBsZXQgc2NvcGVzZXQgPSBzdHguc2NvcGVzZXRzLnBoYXNlLmhhcyhwaGFzZSkgPyBzdHguc2NvcGVzZXRzLnBoYXNlLmdldChwaGFzZSkgOiBMaXN0KCk7XG4gICAgc2NvcGVzZXQgPSBhbGxTY29wZXNldC5jb25jYXQoc2NvcGVzZXQpO1xuICAgIGFzc2VydChwaGFzZSAhPSBudWxsLCAnbXVzdCBwcm92aWRlIGEgcGhhc2UgZm9yIGJpbmRpbmcgYWRkJyk7XG5cbiAgICBsZXQgc2NvcGVzZXRCaW5kaW5nTGlzdCA9IHRoaXMuX21hcC5nZXQoc3R4TmFtZSk7XG4gICAgaWYgKHNjb3Blc2V0QmluZGluZ0xpc3QpIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgc2NvcGVzZXRCaW5kaW5nTGlzdC5wdXNoKHtcbiAgICAgICAgc2NvcGVzOiBzY29wZXNldCxcbiAgICAgICAgYmluZGluZzogYmluZGluZyxcbiAgICAgICAgYWxpYXM6IE1heWJlLm9mKGZvcndhcmRTdHgpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQoc3R4TmFtZSwgTGlzdC5vZih7XG4gICAgICAgIHNjb3Blczogc2NvcGVzZXQsXG4gICAgICAgIGJpbmRpbmc6IGJpbmRpbmcsXG4gICAgICAgIGFsaWFzOiBNYXliZS5vZihmb3J3YXJkU3R4KVxuICAgICAgfSkpO1xuICAgIH1cblxuICB9XG5cbiAgZ2V0KHN0eDogU3ludGF4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc3R4LnRva2VuLnZhbHVlKTtcbiAgfVxufVxuIl19