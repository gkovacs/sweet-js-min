'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = require('immutable');

var _readtable = require('readtable');

var _readIdentifier = require('./read-identifier');

var _readIdentifier2 = _interopRequireDefault(_readIdentifier);

var _readNumeric = require('./read-numeric');

var _readNumeric2 = _interopRequireDefault(_readNumeric);

var _readString = require('./read-string');

var _readString2 = _interopRequireDefault(_readString);

var _readTemplate = require('./read-template');

var _readTemplate2 = _interopRequireDefault(_readTemplate);

var _readRegexp = require('./read-regexp.js');

var _readRegexp2 = _interopRequireDefault(_readRegexp);

var _readComment = require('./read-comment');

var _readComment2 = _interopRequireDefault(_readComment);

var _readDispatch = require('./read-dispatch');

var _tokens = require('../tokens');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// use https://github.com/mathiasbynens/regenerate to generate the Unicode code points when implementing modes

function eatWhitespace(stream) {
  stream.readString();
  return _tokens.EmptyToken;
}

const punctuatorTable = Object.keys(_tokens.punctuatorTable).reduce(_utils.insertSequence, {});

function readPunctuator(stream) {
  const len = (0, _utils.retrieveSequenceLength)(punctuatorTable, stream, 0);
  if (len > 0) {
    return new _tokens.PunctuatorToken({
      value: stream.readString(len)
    });
  }
  throw Error('Unknown punctuator');
}

const punctuatorEntries = Object.keys(punctuatorTable).map(p => ({
  key: p,
  mode: 'terminating',
  action: readPunctuator
}));

const whiteSpaceTable = [0x20, 0x09, 0x0B, 0x0C, 0xA0, 0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

const whiteSpaceEntries = whiteSpaceTable.map(w => ({
  key: w,
  mode: 'terminating',
  action: eatWhitespace
}));

const lineTerminatorTable = [0x0A, 0x0D, 0x2028, 0x2029];

const lineTerminatorEntries = lineTerminatorTable.map(lt => ({
  key: lt,
  mode: 'terminating',
  action: function readLineTerminator(stream) {
    this.incrementLine();
    return eatWhitespace(stream);
  }
}));

const digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

const numericEntries = digits.map(d => ({
  key: d,
  mode: 'non-terminating',
  action: _readNumeric2.default
}));

const quotes = ['\'', '"'];

const stringEntries = quotes.map(q => ({
  key: q,
  mode: 'terminating',
  action: _readString2.default
}));

const identifierEntry = {
  mode: 'non-terminating',
  action: _readIdentifier2.default
};

const templateEntry = {
  key: '`',
  mode: 'terminating',
  action: _readTemplate2.default
};

const primitiveReadtable = (0, _readtable.getCurrentReadtable)().extend(...[identifierEntry, ...whiteSpaceEntries, templateEntry, ...punctuatorEntries, ...lineTerminatorEntries, ...numericEntries, ...stringEntries]);

const dotEntry = {
  key: '.',
  mode: 'terminating',
  action: function readDot(stream, ...rest) {
    const nxt = stream.peek(1).charCodeAt(0);
    if ((0, _utils.isDecimalDigit)(nxt)) {
      return (0, _readNumeric2.default)(stream, ...rest);
    }
    return readPunctuator.call(this, stream);
  }
};

const keywordTable = Object.keys(_tokens.keywordTable).reduce(_utils.insertSequence, {});

const keywordEntries = Object.keys(keywordTable).map(k => ({
  key: k,
  mode: 'non-terminating',
  action: function readKeyword(stream) {
    const len = (0, _utils.retrieveSequenceLength)(keywordTable, stream, 0);
    if (len > 0 && !(0, _utils.isIdentifierPart)(stream.peek(len).charCodeAt(0))) {
      return new _tokens.KeywordToken({
        value: stream.readString(len)
      });
    }
    return _readIdentifier2.default.call(this, stream);
  }
}));

const delimiterPairs = [['[', ']'], ['(', ')']];

function readDelimiters(closing, stream, prefix, b) {
  const currentReadtable = (0, _readtable.getCurrentReadtable)();
  (0, _readtable.setCurrentReadtable)(primitiveReadtable);

  let results = _immutable.List.of(this.readToken(stream, (0, _immutable.List)(), b));

  (0, _readtable.setCurrentReadtable)(currentReadtable);
  return this.readUntil(closing, stream, results, b);
}

const delimiterEntries = delimiterPairs.map(p => ({
  key: p[0],
  mode: 'terminating',
  action: function readDefaultDelimiters(stream, prefix, b) {
    return readDelimiters.call(this, p[1], stream, prefix, true);
  }
}));

const bracesEntry = {
  key: '{',
  mode: 'terminating',
  action: function readBraces(stream, prefix, b) {
    const line = this.locationInfo.line;
    const innerB = (0, _utils.isExprPrefix)(line, b, prefix);
    return readDelimiters.call(this, '}', stream, prefix, innerB);
  }
};

function readClosingDelimiter(opening, closing, stream, prefix, b) {
  if (prefix.first().value !== opening) {
    throw Error('Unmatched delimiter:', closing);
  }
  return readPunctuator.call(this, stream);
}

const unmatchedDelimiterEntries = [['{', '}'], ['[', ']'], ['(', ')']].map(p => ({
  key: p[1],
  mode: 'terminating',
  action: function readClosingDelimiters(stream, prefix, b) {
    return readClosingDelimiter.call(this, ...p, stream, prefix, b);
  }
}));

const divEntry = {
  key: '/',
  mode: 'terminating',
  action: function readDiv(stream, prefix, b) {
    let nxt = stream.peek(1);
    if (nxt === '/' || nxt === '*') {
      const result = _readComment2.default.call(this, stream);
      return result;
    }
    if ((0, _utils.isRegexPrefix)(b, prefix)) {
      return _readRegexp2.default.call(this, stream, prefix, b);
    }
    return readPunctuator.call(this, stream);
  }
};

const dispatchBacktickEntry = {
  key: '`',
  mode: 'dispatch',
  action: _readDispatch.readSyntaxTemplate
};

const defaultDispatchEntry = {
  mode: 'dispatch',
  action: function readDefaultDispatch(...args) {
    this.readToken(...args);
    return _tokens.EmptyToken;
  }
};

const dispatchWhiteSpaceEntries = whiteSpaceTable.concat(lineTerminatorTable).map(w => ({
  key: w,
  mode: 'dispatch',
  action: function readDispatchWhitespace(stream, prefix, allowExprs, dispatchKey) {
    this.readToken(stream, prefix, allowExprs);
    return new _tokens.IdentifierToken({ value: dispatchKey });
  }
}));

const atEntry = {
  key: '@',
  mode: 'terminating',
  action: function readAt(stream, prefix) {
    const nxt = stream.peek(1),
          nxtCode = nxt.charCodeAt(0);
    if ((0, _readtable.isEOS)(nxt) || (0, _utils.isWhiteSpace)(nxtCode) || (0, _utils.isLineTerminator)(nxtCode)) {
      return new _tokens.IdentifierToken({ value: stream.readString() });
    }
    throw new SyntaxError('Invalid or unexpected token');
  }
};

const defaultReadtable = primitiveReadtable.extend(...[dotEntry, ...delimiterEntries, ...unmatchedDelimiterEntries, bracesEntry, divEntry, ...keywordEntries, defaultDispatchEntry, dispatchBacktickEntry, ...dispatchWhiteSpaceEntries, atEntry]);

exports.default = defaultReadtable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvZGVmYXVsdC1yZWFkdGFibGUuanMiXSwibmFtZXMiOlsiZWF0V2hpdGVzcGFjZSIsInN0cmVhbSIsInJlYWRTdHJpbmciLCJwdW5jdHVhdG9yVGFibGUiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicmVhZFB1bmN0dWF0b3IiLCJsZW4iLCJ2YWx1ZSIsIkVycm9yIiwicHVuY3R1YXRvckVudHJpZXMiLCJtYXAiLCJwIiwia2V5IiwibW9kZSIsImFjdGlvbiIsIndoaXRlU3BhY2VUYWJsZSIsIndoaXRlU3BhY2VFbnRyaWVzIiwidyIsImxpbmVUZXJtaW5hdG9yVGFibGUiLCJsaW5lVGVybWluYXRvckVudHJpZXMiLCJsdCIsInJlYWRMaW5lVGVybWluYXRvciIsImluY3JlbWVudExpbmUiLCJkaWdpdHMiLCJudW1lcmljRW50cmllcyIsImQiLCJxdW90ZXMiLCJzdHJpbmdFbnRyaWVzIiwicSIsImlkZW50aWZpZXJFbnRyeSIsInRlbXBsYXRlRW50cnkiLCJwcmltaXRpdmVSZWFkdGFibGUiLCJleHRlbmQiLCJkb3RFbnRyeSIsInJlYWREb3QiLCJyZXN0Iiwibnh0IiwicGVlayIsImNoYXJDb2RlQXQiLCJjYWxsIiwia2V5d29yZFRhYmxlIiwia2V5d29yZEVudHJpZXMiLCJrIiwicmVhZEtleXdvcmQiLCJkZWxpbWl0ZXJQYWlycyIsInJlYWREZWxpbWl0ZXJzIiwiY2xvc2luZyIsInByZWZpeCIsImIiLCJjdXJyZW50UmVhZHRhYmxlIiwicmVzdWx0cyIsIm9mIiwicmVhZFRva2VuIiwicmVhZFVudGlsIiwiZGVsaW1pdGVyRW50cmllcyIsInJlYWREZWZhdWx0RGVsaW1pdGVycyIsImJyYWNlc0VudHJ5IiwicmVhZEJyYWNlcyIsImxpbmUiLCJsb2NhdGlvbkluZm8iLCJpbm5lckIiLCJyZWFkQ2xvc2luZ0RlbGltaXRlciIsIm9wZW5pbmciLCJmaXJzdCIsInVubWF0Y2hlZERlbGltaXRlckVudHJpZXMiLCJyZWFkQ2xvc2luZ0RlbGltaXRlcnMiLCJkaXZFbnRyeSIsInJlYWREaXYiLCJyZXN1bHQiLCJkaXNwYXRjaEJhY2t0aWNrRW50cnkiLCJkZWZhdWx0RGlzcGF0Y2hFbnRyeSIsInJlYWREZWZhdWx0RGlzcGF0Y2giLCJhcmdzIiwiZGlzcGF0Y2hXaGl0ZVNwYWNlRW50cmllcyIsImNvbmNhdCIsInJlYWREaXNwYXRjaFdoaXRlc3BhY2UiLCJhbGxvd0V4cHJzIiwiZGlzcGF0Y2hLZXkiLCJhdEVudHJ5IiwicmVhZEF0Iiwibnh0Q29kZSIsIlN5bnRheEVycm9yIiwiZGVmYXVsdFJlYWR0YWJsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQSxTQUFTQSxhQUFULENBQXVCQyxNQUF2QixFQUEyQztBQUN6Q0EsU0FBT0MsVUFBUDtBQUNBO0FBQ0Q7O0FBRUQsTUFBTUMsa0JBQWtCQyxPQUFPQyxJQUFQLDBCQUErQkMsTUFBL0Isd0JBQXNELEVBQXRELENBQXhCOztBQUVBLFNBQVNDLGNBQVQsQ0FBd0JOLE1BQXhCLEVBQWdDO0FBQzlCLFFBQU1PLE1BQU0sbUNBQXVCTCxlQUF2QixFQUF3Q0YsTUFBeEMsRUFBZ0QsQ0FBaEQsQ0FBWjtBQUNBLE1BQUlPLE1BQU0sQ0FBVixFQUFhO0FBQ1gsV0FBTyw0QkFBb0I7QUFDekJDLGFBQU9SLE9BQU9DLFVBQVAsQ0FBa0JNLEdBQWxCO0FBRGtCLEtBQXBCLENBQVA7QUFHRDtBQUNELFFBQU1FLE1BQU0sb0JBQU4sQ0FBTjtBQUNEOztBQUVELE1BQU1DLG9CQUFvQlAsT0FBT0MsSUFBUCxDQUFZRixlQUFaLEVBQTZCUyxHQUE3QixDQUFpQ0MsTUFBTTtBQUMvREMsT0FBS0QsQ0FEMEQ7QUFFL0RFLFFBQU0sYUFGeUQ7QUFHL0RDLFVBQVFUO0FBSHVELENBQU4sQ0FBakMsQ0FBMUI7O0FBTUEsTUFBTVUsa0JBQWtC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UUFBRCxFQUNELEdBQUdxQixnQkFERixFQUVELEdBQUdVLHlCQUZGLEVBR0RSLFdBSEMsRUFJRFUsUUFKQyxFQUtELEdBQUd6QixjQUxGLEVBTUQ2QixvQkFOQyxFQU9ERCxxQkFQQyxFQVFELEdBQUdJLHlCQVJGLEVBU0RLLE9BVEMsQ0FEb0IsQ0FBekI7O2tCQVllSSxnQiIsImZpbGUiOiJkZWZhdWx0LXJlYWR0YWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgaXNFT1MsIGdldEN1cnJlbnRSZWFkdGFibGUsIHNldEN1cnJlbnRSZWFkdGFibGUgfSBmcm9tICdyZWFkdGFibGUnO1xuaW1wb3J0IHJlYWRJZGVudGlmaWVyIGZyb20gJy4vcmVhZC1pZGVudGlmaWVyJztcbmltcG9ydCByZWFkTnVtZXJpY0xpdGVyYWwgZnJvbSAnLi9yZWFkLW51bWVyaWMnO1xuaW1wb3J0IHJlYWRTdHJpbmdMaXRlcmFsIGZyb20gJy4vcmVhZC1zdHJpbmcnO1xuaW1wb3J0IHJlYWRUZW1wbGF0ZUxpdGVyYWwgZnJvbSAnLi9yZWFkLXRlbXBsYXRlJztcbmltcG9ydCByZWFkUmVnRXhwIGZyb20gJy4vcmVhZC1yZWdleHAuanMnO1xuaW1wb3J0IHJlYWRDb21tZW50IGZyb20gJy4vcmVhZC1jb21tZW50JztcbmltcG9ydCB7IHJlYWRTeW50YXhUZW1wbGF0ZSB9IGZyb20gJy4vcmVhZC1kaXNwYXRjaCc7XG5pbXBvcnQgeyBwdW5jdHVhdG9yVGFibGUgYXMgcHVuY3R1YXRvck1hcHBpbmcsIGtleXdvcmRUYWJsZSBhcyBrZXl3b3JkTWFwcGluZyxcbiAgICAgICAgIEtleXdvcmRUb2tlbiwgUHVuY3R1YXRvclRva2VuLCBFbXB0eVRva2VuLCBJZGVudGlmaWVyVG9rZW4gfSBmcm9tICcuLi90b2tlbnMnO1xuaW1wb3J0IHsgaW5zZXJ0U2VxdWVuY2UsIHJldHJpZXZlU2VxdWVuY2VMZW5ndGgsIGlzRXhwclByZWZpeCwgaXNSZWdleFByZWZpeCwgaXNJZGVudGlmaWVyUGFydCwgaXNXaGl0ZVNwYWNlLCBpc0xpbmVUZXJtaW5hdG9yLCBpc0RlY2ltYWxEaWdpdCB9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSAgeyBDaGFyU3RyZWFtIH0gZnJvbSAncmVhZHRhYmxlJztcblxuLy8gdXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGUgdG8gZ2VuZXJhdGUgdGhlIFVuaWNvZGUgY29kZSBwb2ludHMgd2hlbiBpbXBsZW1lbnRpbmcgbW9kZXNcblxuZnVuY3Rpb24gZWF0V2hpdGVzcGFjZShzdHJlYW06IENoYXJTdHJlYW0pIHtcbiAgc3RyZWFtLnJlYWRTdHJpbmcoKTtcbiAgcmV0dXJuIEVtcHR5VG9rZW47XG59XG5cbmNvbnN0IHB1bmN0dWF0b3JUYWJsZSA9IE9iamVjdC5rZXlzKHB1bmN0dWF0b3JNYXBwaW5nKS5yZWR1Y2UoaW5zZXJ0U2VxdWVuY2UsIHt9KTtcblxuZnVuY3Rpb24gcmVhZFB1bmN0dWF0b3Ioc3RyZWFtKSB7XG4gIGNvbnN0IGxlbiA9IHJldHJpZXZlU2VxdWVuY2VMZW5ndGgocHVuY3R1YXRvclRhYmxlLCBzdHJlYW0sIDApO1xuICBpZiAobGVuID4gMCkge1xuICAgIHJldHVybiBuZXcgUHVuY3R1YXRvclRva2VuKHtcbiAgICAgIHZhbHVlOiBzdHJlYW0ucmVhZFN0cmluZyhsZW4pXG4gICAgfSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vua25vd24gcHVuY3R1YXRvcicpO1xufVxuXG5jb25zdCBwdW5jdHVhdG9yRW50cmllcyA9IE9iamVjdC5rZXlzKHB1bmN0dWF0b3JUYWJsZSkubWFwKHAgPT4gKHtcbiAga2V5OiBwLFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IHJlYWRQdW5jdHVhdG9yXG59KSk7XG5cbmNvbnN0IHdoaXRlU3BhY2VUYWJsZSA9IFsweDIwLCAweDA5LCAweDBCLCAweDBDLCAweEEwLCAweDE2ODAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXTtcblxuY29uc3Qgd2hpdGVTcGFjZUVudHJpZXMgPSB3aGl0ZVNwYWNlVGFibGUubWFwKHcgPT4gKHtcbiAga2V5OiB3LFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IGVhdFdoaXRlc3BhY2Vcbn0pKTtcblxuY29uc3QgbGluZVRlcm1pbmF0b3JUYWJsZSA9IFsweDBBLCAweDBELCAweDIwMjgsIDB4MjAyOV07XG5cbmNvbnN0IGxpbmVUZXJtaW5hdG9yRW50cmllcyA9IGxpbmVUZXJtaW5hdG9yVGFibGUubWFwKGx0ID0+ICh7XG4gIGtleTogbHQsXG4gIG1vZGU6ICd0ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZExpbmVUZXJtaW5hdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuaW5jcmVtZW50TGluZSgpO1xuICAgIHJldHVybiBlYXRXaGl0ZXNwYWNlKHN0cmVhbSk7XG4gIH1cbn0pKTtcblxuY29uc3QgZGlnaXRzID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5J107XG5cbmNvbnN0IG51bWVyaWNFbnRyaWVzID0gZGlnaXRzLm1hcChkID0+ICh7XG4gIGtleTogZCxcbiAgbW9kZTogJ25vbi10ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogcmVhZE51bWVyaWNMaXRlcmFsXG59KSk7XG5cbmNvbnN0IHF1b3RlcyA9IFsnXFwnJywgJ1wiJ107XG5cbmNvbnN0IHN0cmluZ0VudHJpZXMgPSBxdW90ZXMubWFwKHEgPT4gKHtcbiAga2V5OiBxLFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IHJlYWRTdHJpbmdMaXRlcmFsXG59KSk7XG5cbmNvbnN0IGlkZW50aWZpZXJFbnRyeSA9IHtcbiAgbW9kZTogJ25vbi10ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogcmVhZElkZW50aWZpZXJcbn07XG5cbmNvbnN0IHRlbXBsYXRlRW50cnkgPSB7XG4gIGtleTogJ2AnLFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IHJlYWRUZW1wbGF0ZUxpdGVyYWxcbn07XG5cbmNvbnN0IHByaW1pdGl2ZVJlYWR0YWJsZSA9IGdldEN1cnJlbnRSZWFkdGFibGUoKS5leHRlbmQoXG4gICAgLi4uW2lkZW50aWZpZXJFbnRyeSxcbiAgICAgICAgLi4ud2hpdGVTcGFjZUVudHJpZXMsXG4gICAgICAgIHRlbXBsYXRlRW50cnksXG4gICAgICAgIC4uLnB1bmN0dWF0b3JFbnRyaWVzLFxuICAgICAgICAuLi5saW5lVGVybWluYXRvckVudHJpZXMsXG4gICAgICAgIC4uLm51bWVyaWNFbnRyaWVzLFxuICAgICAgICAuLi5zdHJpbmdFbnRyaWVzXSk7XG5cbmNvbnN0IGRvdEVudHJ5ID0ge1xuICBrZXk6ICcuJyxcbiAgbW9kZTogJ3Rlcm1pbmF0aW5nJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkRG90KHN0cmVhbSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG54dCA9IHN0cmVhbS5wZWVrKDEpLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KG54dCkpIHtcbiAgICAgIHJldHVybiByZWFkTnVtZXJpY0xpdGVyYWwoc3RyZWFtLCAuLi5yZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRQdW5jdHVhdG9yLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgfVxufTtcblxuY29uc3Qga2V5d29yZFRhYmxlID0gT2JqZWN0LmtleXMoa2V5d29yZE1hcHBpbmcpLnJlZHVjZShpbnNlcnRTZXF1ZW5jZSwge30pO1xuXG5jb25zdCBrZXl3b3JkRW50cmllcyA9IE9iamVjdC5rZXlzKGtleXdvcmRUYWJsZSkubWFwKGsgPT4gKHtcbiAga2V5OiBrLFxuICBtb2RlOiAnbm9uLXRlcm1pbmF0aW5nJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkS2V5d29yZChzdHJlYW0pIHtcbiAgICBjb25zdCBsZW4gPSByZXRyaWV2ZVNlcXVlbmNlTGVuZ3RoKGtleXdvcmRUYWJsZSwgc3RyZWFtLCAwKTtcbiAgICBpZiAobGVuID4gMCAmJiAhaXNJZGVudGlmaWVyUGFydChzdHJlYW0ucGVlayhsZW4pLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICByZXR1cm4gbmV3IEtleXdvcmRUb2tlbih7XG4gICAgICAgIHZhbHVlOiBzdHJlYW0ucmVhZFN0cmluZyhsZW4pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRJZGVudGlmaWVyLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgfVxufSkpO1xuXG5jb25zdCBkZWxpbWl0ZXJQYWlycyA9IFtbJ1snLCddJ10sIFsnKCcsJyknXV07XG5cbmZ1bmN0aW9uIHJlYWREZWxpbWl0ZXJzKGNsb3NpbmcsIHN0cmVhbSwgcHJlZml4LCBiKSB7XG4gIGNvbnN0IGN1cnJlbnRSZWFkdGFibGUgPSBnZXRDdXJyZW50UmVhZHRhYmxlKCk7XG4gIHNldEN1cnJlbnRSZWFkdGFibGUocHJpbWl0aXZlUmVhZHRhYmxlKTtcblxuICBsZXQgcmVzdWx0cyA9IExpc3Qub2YodGhpcy5yZWFkVG9rZW4oc3RyZWFtLCBMaXN0KCksIGIpKTtcblxuICBzZXRDdXJyZW50UmVhZHRhYmxlKGN1cnJlbnRSZWFkdGFibGUpO1xuICByZXR1cm4gdGhpcy5yZWFkVW50aWwoY2xvc2luZywgc3RyZWFtLCByZXN1bHRzLCBiKTtcbn1cblxuY29uc3QgZGVsaW1pdGVyRW50cmllcyA9IGRlbGltaXRlclBhaXJzLm1hcChwID0+ICh7XG4gIGtleTogcFswXSxcbiAgbW9kZTogJ3Rlcm1pbmF0aW5nJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkRGVmYXVsdERlbGltaXRlcnMoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICByZXR1cm4gcmVhZERlbGltaXRlcnMuY2FsbCh0aGlzLCBwWzFdLCBzdHJlYW0sIHByZWZpeCwgdHJ1ZSk7XG4gIH1cbn0pKTtcblxuY29uc3QgYnJhY2VzRW50cnkgPSB7XG4gIGtleTogJ3snLFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWRCcmFjZXMoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICBjb25zdCBsaW5lID0gdGhpcy5sb2NhdGlvbkluZm8ubGluZTtcbiAgICBjb25zdCBpbm5lckIgPSBpc0V4cHJQcmVmaXgobGluZSwgYiwgcHJlZml4KTtcbiAgICByZXR1cm4gcmVhZERlbGltaXRlcnMuY2FsbCh0aGlzLCAnfScsIHN0cmVhbSwgcHJlZml4LCBpbm5lckIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWFkQ2xvc2luZ0RlbGltaXRlcihvcGVuaW5nLCBjbG9zaW5nLCBzdHJlYW0sIHByZWZpeCwgYikge1xuICBpZiAocHJlZml4LmZpcnN0KCkudmFsdWUgIT09IG9wZW5pbmcpIHtcbiAgICB0aHJvdyBFcnJvcignVW5tYXRjaGVkIGRlbGltaXRlcjonLCBjbG9zaW5nKTtcbiAgfVxuICByZXR1cm4gcmVhZFB1bmN0dWF0b3IuY2FsbCh0aGlzLCBzdHJlYW0pO1xufVxuXG5jb25zdCB1bm1hdGNoZWREZWxpbWl0ZXJFbnRyaWVzID0gW1sneycsJ30nXSwgWydbJywnXSddLCBbJygnLCcpJ11dLm1hcChwID0+ICh7XG4gIGtleTogcFsxXSxcbiAgbW9kZTogJ3Rlcm1pbmF0aW5nJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiByZWFkQ2xvc2luZ0RlbGltaXRlcnMoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICByZXR1cm4gcmVhZENsb3NpbmdEZWxpbWl0ZXIuY2FsbCh0aGlzLCAuLi5wLCBzdHJlYW0sIHByZWZpeCwgYik7XG4gIH1cbn0pKTtcblxuY29uc3QgZGl2RW50cnkgPSB7XG4gIGtleTogJy8nLFxuICBtb2RlOiAndGVybWluYXRpbmcnLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWREaXYoc3RyZWFtLCBwcmVmaXgsIGIpIHtcbiAgICBsZXQgbnh0ID0gc3RyZWFtLnBlZWsoMSk7XG4gICAgaWYgKG54dCA9PT0gJy8nIHx8IG54dCA9PT0gJyonKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWFkQ29tbWVudC5jYWxsKHRoaXMsIHN0cmVhbSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoaXNSZWdleFByZWZpeChiLCBwcmVmaXgpKSB7XG4gICAgICByZXR1cm4gcmVhZFJlZ0V4cC5jYWxsKHRoaXMsIHN0cmVhbSwgcHJlZml4LCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRQdW5jdHVhdG9yLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgfVxufTtcblxuY29uc3QgZGlzcGF0Y2hCYWNrdGlja0VudHJ5ID0ge1xuICBrZXk6ICdgJyxcbiAgbW9kZTogJ2Rpc3BhdGNoJyxcbiAgYWN0aW9uOiByZWFkU3ludGF4VGVtcGxhdGVcbn07XG5cbmNvbnN0IGRlZmF1bHREaXNwYXRjaEVudHJ5ID0ge1xuICBtb2RlOiAnZGlzcGF0Y2gnLFxuICBhY3Rpb246IGZ1bmN0aW9uIHJlYWREZWZhdWx0RGlzcGF0Y2goLi4uYXJncykge1xuICAgIHRoaXMucmVhZFRva2VuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBFbXB0eVRva2VuO1xuICB9XG59O1xuXG5jb25zdCBkaXNwYXRjaFdoaXRlU3BhY2VFbnRyaWVzID0gd2hpdGVTcGFjZVRhYmxlLmNvbmNhdChsaW5lVGVybWluYXRvclRhYmxlKS5tYXAodyA9PiAoe1xuICBrZXk6IHcsXG4gIG1vZGU6ICdkaXNwYXRjaCcsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZERpc3BhdGNoV2hpdGVzcGFjZShzdHJlYW0sIHByZWZpeCwgYWxsb3dFeHBycywgZGlzcGF0Y2hLZXkpIHtcbiAgICB0aGlzLnJlYWRUb2tlbihzdHJlYW0sIHByZWZpeCwgYWxsb3dFeHBycyk7XG4gICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyVG9rZW4oeyB2YWx1ZTogZGlzcGF0Y2hLZXkgfSk7XG4gIH1cbn0pKTtcblxuY29uc3QgYXRFbnRyeSA9IHtcbiAga2V5OiAnQCcsXG4gIG1vZGU6ICd0ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZEF0KHN0cmVhbSwgcHJlZml4KSB7XG4gICAgY29uc3Qgbnh0ID0gc3RyZWFtLnBlZWsoMSksIG54dENvZGUgPSBueHQuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoaXNFT1Mobnh0KSB8fCBpc1doaXRlU3BhY2Uobnh0Q29kZSkgfHwgaXNMaW5lVGVybWluYXRvcihueHRDb2RlKSkge1xuICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyVG9rZW4oeyB2YWx1ZTogc3RyZWFtLnJlYWRTdHJpbmcoKSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIG9yIHVuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgfVxufTtcblxuY29uc3QgZGVmYXVsdFJlYWR0YWJsZSA9IHByaW1pdGl2ZVJlYWR0YWJsZS5leHRlbmQoXG4gIC4uLltkb3RFbnRyeSxcbiAgICAuLi5kZWxpbWl0ZXJFbnRyaWVzLFxuICAgIC4uLnVubWF0Y2hlZERlbGltaXRlckVudHJpZXMsXG4gICAgYnJhY2VzRW50cnksXG4gICAgZGl2RW50cnksXG4gICAgLi4ua2V5d29yZEVudHJpZXMsXG4gICAgZGVmYXVsdERpc3BhdGNoRW50cnksXG4gICAgZGlzcGF0Y2hCYWNrdGlja0VudHJ5LFxuICAgIC4uLmRpc3BhdGNoV2hpdGVTcGFjZUVudHJpZXMsXG4gICAgYXRFbnRyeV0pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0UmVhZHRhYmxlO1xuIl19