'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRegexPrefix = exports.isExprPrefix = exports.isTerminating = exports.isIdentifierPart = exports.isIdentifierStart = exports.isDecimalDigit = exports.isWhiteSpace = exports.isLineTerminator = exports.RSYNTAX = exports.LSYNTAX = undefined;
exports.getHexValue = getHexValue;
exports.skipSingleLineComment = skipSingleLineComment;
exports.scanUnicode = scanUnicode;
exports.readStringEscape = readStringEscape;
exports.insertSequence = insertSequence;
exports.retrieveSequenceLength = retrieveSequenceLength;

var _readtable = require('readtable');

var _esutils = require('esutils');

var _ramda = require('ramda');

var R = _interopRequireWildcard(_ramda);

var _ramdaFantasy = require('ramda-fantasy');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const { isLineTerminator,
  isWhiteSpace,
  isDecimalDigit,
  isIdentifierPartES6: isIdentifierPart,
  isIdentifierStartES6: isIdentifierStart } = _esutils.code;

const Just = _ramdaFantasy.Maybe.Just;
const Nothing = _ramdaFantasy.Maybe.Nothing;

const LSYNTAX = exports.LSYNTAX = { name: 'left-syntax' };
const RSYNTAX = exports.RSYNTAX = { name: 'right-syntax' };

// TODO: also, need to handle contextual yield
const literalKeywords = ['this', 'null', 'true', 'false'];

exports.isLineTerminator = isLineTerminator;
exports.isWhiteSpace = isWhiteSpace;
exports.isDecimalDigit = isDecimalDigit;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierPart = isIdentifierPart;
function getHexValue(rune) {
  if ('0' <= rune && rune <= '9') {
    return rune.charCodeAt(0) - 48;
  }
  if ('a' <= rune && rune <= 'f') {
    return rune.charCodeAt(0) - 87;
  }
  if ('A' <= rune && rune <= 'F') {
    return rune.charCodeAt(0) - 55;
  }
  return -1;
}

function skipSingleLineComment(stream) {
  let idx = 0;
  let char = stream.peek(idx);
  while (!(0, _readtable.isEOS)(char)) {
    let chCode = char.charCodeAt(0);
    if (isLineTerminator(chCode)) {
      ++idx;
      if (chCode === 0xD /* "\r" */ && stream.peek(idx).charCodeAt(0) === 0xA /*"\n" */) {
          ++idx;
        }
      this.incrementLine();
      break;
    }
    ++idx;
    char = stream.peek(idx);
  }
  stream.readString(idx);
}

function scanUnicode(stream, start) {
  const sPeek = stream.peek.bind(stream);
  let idx = start;
  let hexDigits = 0;
  if (sPeek(idx) === '{') {
    //\u{HexDigits}
    ++idx;
    let char = sPeek(idx);
    while (!(0, _readtable.isEOS)(char)) {
      let hex = getHexValue(char);
      if (hex === -1) break;
      hexDigits = hexDigits << 4 | hex;
      if (hexDigits > 0x10FFFF) {
        throw this.createILLEGAL(char);
      }
      char = sPeek(++idx);
    }
    if (char !== '}') {
      throw this.createILLEGAL(char);
    }
    if (idx === start + 1) {
      throw this.createILLEGAL(stream.peek(idx + 1));
    }
    ++idx;
  } else {
    //\uHex4Digits
    if ((0, _readtable.isEOS)(sPeek(idx + 3))) return -1;
    let r;
    for (; idx < start + 4; ++idx) {
      r = getHexValue(sPeek(idx));
      if (r === -1) return -1;
      hexDigits = hexDigits << 4 | r;
    }
  }
  stream.readString(idx);

  return hexDigits;
}

function readStringEscape(str, stream, start, octal) {
  let idx = start + 1,
      char = stream.peek(idx),
      lineStart;
  if ((0, _readtable.isEOS)(char)) throw this.createILLEGAL(char);

  if (!isLineTerminator(char.charCodeAt(0))) {
    switch (char) {
      case 'b':
        str += '\b';++idx;break;
      case 'f':
        str += '\f';++idx;break;
      case 'n':
        str += '\n';++idx;break;
      case 'r':
        str += '\r';++idx;break;
      case 't':
        str += '\t';++idx;break;
      case 'v':
        str += '\u000B';++idx;break;
      case 'u':
      case 'x':
        {
          let unescaped;
          ++idx;
          let nxt = stream.peek(idx);
          if ((0, _readtable.isEOS)(nxt)) {
            throw this.createILLEGAL(nxt);
          }
          unescaped = char === 'u' ? scanUnicode.call(this, stream, idx) : scanHexEscape2.call(this, stream);
          if (unescaped === -1) throw this.createILLEGAL(char);
          idx = 0; // stream is read in scanUnicode and scanHexEscape2

          str += String.fromCodePoint(unescaped);
          break;
        }
      default:
        {
          if ('0' <= char && char <= '7') {
            [str, idx, octal] = scanOctal.call(this, str, stream, char, idx, octal);
          } else if (char === '8' || char === '9') {
            throw this.createILLEGAL(char);
          } else {
            str += char;
            ++idx;
          }
        }
    }
  } else {
    if (char === '\r' && stream.peek(idx + 1) === '\n') {
      ++idx;
    }
    ++idx;
    this.incrementLine();
    lineStart = idx;
  }
  return [str, idx, octal, lineStart];
}

function scanOctal(str, stream, char, start, octal) {
  let len = 1,
      idx = start;
  if ('0' <= char && char <= '3') {
    len = 0;
  }
  let code = 0;

  while (len < 3 && '0' <= char && char <= '7') {
    ++idx;
    if (len > 0 || char !== '0') {
      if (octal == null) octal = '';
      octal += char;
    }
    code *= 8;
    code += +char; //coersion
    ++len;
    char = stream.peek(idx);
    if ((0, _readtable.isEOS)(char)) {
      throw this.createILLEGAL(char);
    }
  }
  str += String.fromCharCode(code);
  return [str, idx, octal];
}

function scanHexEscape2(stream, idx) {
  let char = stream.peek(idx);

  if ((0, _readtable.isEOS)(char)) return -1;

  let r1 = getHexValue(stream.peek());
  if (r1 === -1) return r1;

  let r2 = getHexValue(stream.peek(1));
  if (r2 === -1) return r2;

  stream.readString(2);
  return r1 << 4 | r2;
}

function insertSequence(coll, seq) {
  const char = seq[0];
  if (!coll[char]) {
    coll[char] = {};
  }
  if (seq.length === 1) {
    coll[char].isValue = true;
    return coll;
  } else {
    coll[char] = insertSequence(coll[char], seq.slice(1));
    return coll;
  }
}

const isTerminating = exports.isTerminating = table => char => table.getMapping(char).mode === 'terminating';

// check for terminating doesn't work if it's at the start
function retrieveSequenceLength(table, stream, idx) {
  const char = stream.peek(idx);
  if (!table[char]) {
    if (table.isValue) return idx;
    return -1;
  } else {
    return retrieveSequenceLength(table[char], stream, ++idx);
  }
}

// const isEOS = R.whereEq({ type: TokenType.EOS });

// const isHash = R.whereEq({ type: TokenType.IDENTIFIER, value: '#'});

const assignOps = ['=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ','];

const binaryOps = ['+', '-', '*', '/', '%', '<<', '>>', '>>>', '&', '|', '^', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!==', 'instanceof'];

const unaryOps = ['++', '--', '~', '!', 'delete', 'void', 'typeof', 'yield', 'throw', 'new'];

// List -> Boolean
const isEmpty = R.whereEq({ size: 0 });

// Syntax -> Boolean
const isPunctuator = s => s.match('punctuator');
const isKeyword = s => s.match('keyword');
const isParens = s => s.match('parens');
const isBraces = s => s.match('braces');
const isIdentifier = s => s.match('identifier');

// Any -> Syntax -> Boolean
const isVal = R.curry((v, s) => s.val() === v);

// Syntax -> Boolean
const isDot = R.allPass([isPunctuator, isVal('.')]);
const isColon = R.allPass([isPunctuator, isVal(':')]);
const isFunctionKeyword = R.allPass([isKeyword, isVal('function')]);
const isOperator = s => (s.match('punctuator') || s.match('keyword')) && R.any(R.equals(s.val()), assignOps.concat(binaryOps).concat(unaryOps));
const isNonLiteralKeyword = R.allPass([isKeyword, s => R.none(R.equals(s.val()), literalKeywords)]);
const isKeywordExprPrefix = R.allPass([isKeyword, s => R.any(R.equals(s.val()), ['instanceof', 'typeof', 'delete', 'void', 'yield', 'throw', 'new', 'case'])]);
// List a -> a?
let last = p => p.last();
// List a -> Maybe a
let safeLast = R.pipe(R.cond([[isEmpty, R.always(Nothing())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last)]]));

// TODO: better name (areTrue & areFalse)?
// List -> Boolean -> Maybe List
let stuffTrue = R.curry((p, b) => b ? Just(p) : Nothing());
let stuffFalse = R.curry((p, b) => !b ? Just(p) : Nothing());

// List a -> Boolean
let isTopColon = R.pipe(safeLast, R.map(isColon), _ramdaFantasy.Maybe.maybe(false, R.identity));
// List a -> Boolean
let isTopPunctuator = R.pipe(safeLast, R.map(isPunctuator), _ramdaFantasy.Maybe.maybe(false, R.identity));

// Number -> List -> Boolean
let isExprReturn = R.curry((l, p) => {
  let retKwd = safeLast(p);
  let maybeDot = pop(p).chain(safeLast);

  if (maybeDot.map(isDot).getOrElse(false)) {
    return true;
  }
  return retKwd.map(s => {
    return s.match('keyword') && s.val() === 'return' && s.lineNumber() === l;
  }).getOrElse(false);
});

const isTopOperator = R.pipe(safeLast, R.map(isOperator), _ramdaFantasy.Maybe.maybe(false, R.identity));

const isTopKeywordExprPrefix = R.pipe(safeLast, R.map(isKeywordExprPrefix), _ramdaFantasy.Maybe.maybe(false, R.identity));

// Number -> Boolean -> List -> Boolean
let isExprPrefix = exports.isExprPrefix = R.curry((l, b) => R.cond([
// ... ({x: 42} /r/i)
[isEmpty, R.always(b)],
// ... ({x: {x: 42} /r/i })
[isTopColon, R.always(b)],
// ... throw {x: 42} /r/i
[isTopKeywordExprPrefix, R.T],
// ... 42 + {x: 42} /r/i
[isTopOperator, R.T],
// ... for ( ; {x: 42}/r/i)
[isTopPunctuator, R.always(b)],
// ... return {x: 42} /r /i
// ... return\n{x: 42} /r /i
[isExprReturn(l), R.T], [R.T, R.F]]));

// List a -> Maybe List a
let curly = p => safeLast(p).map(isBraces).chain(stuffTrue(p));
let paren = p => safeLast(p).map(isParens).chain(stuffTrue(p));
let func = p => safeLast(p).map(isFunctionKeyword).chain(stuffTrue(p));
let ident = p => safeLast(p).map(isIdentifier).chain(stuffTrue(p));
let nonLiteralKeyword = p => safeLast(p).map(isNonLiteralKeyword).chain(stuffTrue(p));

let opt = R.curry((a, b, p) => {
  let result = R.pipeK(a, b)(_ramdaFantasy.Maybe.of(p));
  return _ramdaFantasy.Maybe.isJust(result) ? result : _ramdaFantasy.Maybe.of(p);
});

let notDot = R.ifElse(R.whereEq({ size: 0 }), Just, p => safeLast(p).map(s => !(s.match('punctuator') && s.val() === '.')).chain(stuffTrue(p)));

// List a -> Maybe List a
let pop = R.compose(Just, p => p.pop());

// Maybe List a -> Maybe List a
const functionPrefix = R.pipeK(curly, pop, paren, pop, opt(ident, pop), func);

// Boolean -> List a -> Boolean
const isRegexPrefix = exports.isRegexPrefix = exprAllowed => R.anyPass([
// ε
isEmpty,
// P . t   where t ∈ Punctuator
isTopPunctuator,
// P . t . t'  where t \not = "." and t' ∈ (Keyword \setminus  LiteralKeyword)
R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
// P . t . t' . (T)  where t \not = "." and t' ∈ (Keyword \setminus LiteralKeyword)
R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren, pop, nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
// P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false
R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, R.chain(p => {
  return safeLast(p).map(s => s.lineNumber()).chain(fnLine => {
    return pop(p).map(isExprPrefix(fnLine, exprAllowed));
  }).chain(stuffFalse(p));
}), _ramdaFantasy.Maybe.isJust),
// P . {T}^l  where isExprPrefix(P, b, l) = false
p => {
  let alreadyCheckedFunction = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, _ramdaFantasy.Maybe.isJust)(p);
  if (alreadyCheckedFunction) {
    return false;
  }
  return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly), R.chain(p => {
    return safeLast(p).map(s => s.lineNumber()).chain(curlyLine => {
      return pop(p).map(isExprPrefix(curlyLine, exprAllowed));
    }).chain(stuffFalse(p));
  }), _ramdaFantasy.Maybe.isJust)(p);
}]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvdXRpbHMuanMiXSwibmFtZXMiOlsiZ2V0SGV4VmFsdWUiLCJza2lwU2luZ2xlTGluZUNvbW1lbnQiLCJzY2FuVW5pY29kZSIsInJlYWRTdHJpbmdFc2NhcGUiLCJpbnNlcnRTZXF1ZW5jZSIsInJldHJpZXZlU2VxdWVuY2VMZW5ndGgiLCJSIiwiaXNMaW5lVGVybWluYXRvciIsImlzV2hpdGVTcGFjZSIsImlzRGVjaW1hbERpZ2l0IiwiaXNJZGVudGlmaWVyUGFydEVTNiIsImlzSWRlbnRpZmllclBhcnQiLCJpc0lkZW50aWZpZXJTdGFydEVTNiIsImlzSWRlbnRpZmllclN0YXJ0IiwiSnVzdCIsIk5vdGhpbmciLCJMU1lOVEFYIiwibmFtZSIsIlJTWU5UQVgiLCJsaXRlcmFsS2V5d29yZHMiLCJydW5lIiwiY2hhckNvZGVBdCIsInN0cmVhbSIsImlkeCIsImNoYXIiLCJwZWVrIiwiY2hDb2RlIiwiaW5jcmVtZW50TGluZSIsInJlYWRTdHJpbmciLCJzdGFydCIsInNQZWVrIiwiYmluZCIsImhleERpZ2l0cyIsImhleCIsImNyZWF0ZUlMTEVHQUwiLCJyIiwic3RyIiwib2N0YWwiLCJsaW5lU3RhcnQiLCJ1bmVzY2FwZWQiLCJueHQiLCJjYWxsIiwic2NhbkhleEVzY2FwZTIiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwic2Nhbk9jdGFsIiwibGVuIiwiY29kZSIsImZyb21DaGFyQ29kZSIsInIxIiwicjIiLCJjb2xsIiwic2VxIiwibGVuZ3RoIiwiaXNWYWx1ZSIsInNsaWNlIiwiaXNUZXJtaW5hdGluZyIsInRhYmxlIiwiZ2V0TWFwcGluZyIsIm1vZGUiLCJhc3NpZ25PcHMiLCJiaW5hcnlPcHMiLCJ1bmFyeU9wcyIsImlzRW1wdHkiLCJ3aGVyZUVxIiwic2l6ZSIsImlzUHVuY3R1YXRvciIsInMiLCJtYXRjaCIsImlzS2V5d29yZCIsImlzUGFyZW5zIiwiaXNCcmFjZXMiLCJpc0lkZW50aWZpZXIiLCJpc1ZhbCIsImN1cnJ5IiwidiIsInZhbCIsImlzRG90IiwiYWxsUGFzcyIsImlzQ29sb24iLCJpc0Z1bmN0aW9uS2V5d29yZCIsImlzT3BlcmF0b3IiLCJhbnkiLCJlcXVhbHMiLCJjb25jYXQiLCJpc05vbkxpdGVyYWxLZXl3b3JkIiwibm9uZSIsImlzS2V5d29yZEV4cHJQcmVmaXgiLCJsYXN0IiwicCIsInNhZmVMYXN0IiwicGlwZSIsImNvbmQiLCJhbHdheXMiLCJUIiwiY29tcG9zZSIsIm9mIiwic3R1ZmZUcnVlIiwiYiIsInN0dWZmRmFsc2UiLCJpc1RvcENvbG9uIiwibWFwIiwibWF5YmUiLCJpZGVudGl0eSIsImlzVG9wUHVuY3R1YXRvciIsImlzRXhwclJldHVybiIsImwiLCJyZXRLd2QiLCJtYXliZURvdCIsInBvcCIsImNoYWluIiwiZ2V0T3JFbHNlIiwibGluZU51bWJlciIsImlzVG9wT3BlcmF0b3IiLCJpc1RvcEtleXdvcmRFeHByUHJlZml4IiwiaXNFeHByUHJlZml4IiwiRiIsImN1cmx5IiwicGFyZW4iLCJmdW5jIiwiaWRlbnQiLCJub25MaXRlcmFsS2V5d29yZCIsIm9wdCIsImEiLCJyZXN1bHQiLCJwaXBlSyIsImlzSnVzdCIsIm5vdERvdCIsImlmRWxzZSIsImZ1bmN0aW9uUHJlZml4IiwiaXNSZWdleFByZWZpeCIsImV4cHJBbGxvd2VkIiwiYW55UGFzcyIsImZuTGluZSIsImFscmVhZHlDaGVja2VkRnVuY3Rpb24iLCJjdXJseUxpbmUiXSwibWFwcGluZ3MiOiI7Ozs7OztRQTBCZ0JBLFcsR0FBQUEsVztRQWFBQyxxQixHQUFBQSxxQjtRQW1CQUMsVyxHQUFBQSxXO1FBdUNBQyxnQixHQUFBQSxnQjtRQTJGQUMsYyxHQUFBQSxjO1FBaUJBQyxzQixHQUFBQSxzQjs7QUEzTWhCOztBQUlBOztBQU9BOztJQUFZQyxDOztBQUNaOzs7O0FBUEEsTUFBTSxFQUFFQyxnQkFBRjtBQUNFQyxjQURGO0FBRUVDLGdCQUZGO0FBR0VDLHVCQUFxQkMsZ0JBSHZCO0FBSUVDLHdCQUFzQkMsaUJBSnhC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QU1xQyxNQVpSLENBNUIrRDtBQTBDL0Q7QUFDQXJDLEtBQUs7QUFDSCxNQUFJNkMseUJBQXlCaEksRUFBRXFGLElBQUYsQ0FDM0Isb0JBQU1LLEVBRHFCLEVBRTNCaUMsY0FGMkIsRUFHM0Isb0JBQU1ILE1BSHFCLEVBSTNCckMsQ0FKMkIsQ0FBN0I7QUFLQSxNQUFJNkMsc0JBQUosRUFBNEI7QUFDMUIsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFPaEksRUFBRXFGLElBQUYsQ0FDTCxvQkFBTUssRUFERCxFQUVMMUYsRUFBRXdHLEtBQUYsQ0FBUU8sS0FBUixDQUZLLEVBR0wvRyxFQUFFd0csS0FBRixDQUFRckIsS0FBSztBQUNYLFdBQU9DLFNBQVNELENBQVQsRUFDTlksR0FETSxDQUNGbEMsS0FBS0EsRUFBRTZDLFVBQUYsRUFESCxFQUVORixLQUZNLENBRUF5QixhQUFhO0FBQ2xCLGFBQU8xQixJQUFJcEIsQ0FBSixFQUFPWSxHQUFQLENBQVdjLGFBQWFvQixTQUFiLEVBQXdCSixXQUF4QixDQUFYLENBQVA7QUFDRCxLQUpNLEVBS05yQixLQUxNLENBS0FYLFdBQVdWLENBQVgsQ0FMQSxDQUFQO0FBTUQsR0FQRCxDQUhLLEVBV0wsb0JBQU1xQyxNQVhELEVBWUxyQyxDQVpLLENBQVA7QUFhRCxDQWpFOEQsQ0FBVixDQUFoRCIsImZpbGUiOiJ1dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7IGlzRU9TIH0gZnJvbSAncmVhZHRhYmxlJztcblxuaW1wb3J0IHR5cGUgeyBSZWFkdGFibGUsIENoYXJTdHJlYW0gfSBmcm9tICdyZWFkdGFibGUnO1xuXG5pbXBvcnQgeyBjb2RlICB9IGZyb20gJ2VzdXRpbHMnO1xuY29uc3QgeyBpc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBpc1doaXRlU3BhY2UsXG4gICAgICAgIGlzRGVjaW1hbERpZ2l0LFxuICAgICAgICBpc0lkZW50aWZpZXJQYXJ0RVM2OiBpc0lkZW50aWZpZXJQYXJ0LFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydEVTNjogaXNJZGVudGlmaWVyU3RhcnQgfSA9IGNvZGU7XG5cbmltcG9ydCAqIGFzIFIgZnJvbSAncmFtZGEnO1xuaW1wb3J0IHsgTWF5YmUgfSBmcm9tICdyYW1kYS1mYW50YXN5JztcbmNvbnN0IEp1c3QgPSBNYXliZS5KdXN0O1xuY29uc3QgTm90aGluZyA9IE1heWJlLk5vdGhpbmc7XG5cbmV4cG9ydCBjb25zdCBMU1lOVEFYID0geyBuYW1lOiAnbGVmdC1zeW50YXgnIH07XG5leHBvcnQgY29uc3QgUlNZTlRBWCA9IHsgbmFtZTogJ3JpZ2h0LXN5bnRheCcgfTtcblxuLy8gVE9ETzogYWxzbywgbmVlZCB0byBoYW5kbGUgY29udGV4dHVhbCB5aWVsZFxuY29uc3QgbGl0ZXJhbEtleXdvcmRzID0gWyd0aGlzJywgJ251bGwnLCAndHJ1ZScsICdmYWxzZSddO1xuXG5leHBvcnQgeyBpc0xpbmVUZXJtaW5hdG9yLCBpc1doaXRlU3BhY2UsIGlzRGVjaW1hbERpZ2l0LCBpc0lkZW50aWZpZXJTdGFydCwgaXNJZGVudGlmaWVyUGFydCB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGV4VmFsdWUocnVuZTogc3RyaW5nKSB7XG4gIGlmICgnMCcgPD0gcnVuZSAmJiBydW5lIDw9ICc5Jykge1xuICAgIHJldHVybiBydW5lLmNoYXJDb2RlQXQoMCkgLSA0ODtcbiAgfVxuICBpZiAoJ2EnIDw9IHJ1bmUgJiYgcnVuZSA8PSAnZicpIHtcbiAgICByZXR1cm4gcnVuZS5jaGFyQ29kZUF0KDApIC0gODc7XG4gIH1cbiAgaWYgKCdBJyA8PSBydW5lICYmIHJ1bmUgPD0gJ0YnKSB7XG4gICAgcmV0dXJuIHJ1bmUuY2hhckNvZGVBdCgwKSAtIDU1O1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNraXBTaW5nbGVMaW5lQ29tbWVudChzdHJlYW06IENoYXJTdHJlYW0pOiB2b2lkIHtcbiAgbGV0IGlkeCA9IDA7XG4gIGxldCBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgd2hpbGUgKCFpc0VPUyhjaGFyKSkge1xuICAgIGxldCBjaENvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2hDb2RlKSkge1xuICAgICAgKytpZHg7XG4gICAgICBpZiAoY2hDb2RlID09PSAweEQgLyogXCJcXHJcIiAqLyAmJiBzdHJlYW0ucGVlayhpZHgpLmNoYXJDb2RlQXQoMCkgPT09IDB4QSAvKlwiXFxuXCIgKi8pIHtcbiAgICAgICAgKytpZHg7XG4gICAgICB9XG4gICAgICB0aGlzLmluY3JlbWVudExpbmUoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2lkeDtcbiAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgfVxuICBzdHJlYW0ucmVhZFN0cmluZyhpZHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhblVuaWNvZGUoc3RyZWFtOiBDaGFyU3RyZWFtLCBzdGFydDogbnVtYmVyKSB7XG4gIGNvbnN0IHNQZWVrID0gc3RyZWFtLnBlZWsuYmluZChzdHJlYW0pO1xuICBsZXQgaWR4ID0gc3RhcnQ7XG4gIGxldCBoZXhEaWdpdHMgPSAwO1xuICBpZiAoc1BlZWsoaWR4KSA9PT0gJ3snKSB7XG4gICAgLy9cXHV7SGV4RGlnaXRzfVxuICAgICsraWR4O1xuICAgIGxldCBjaGFyID0gc1BlZWsoaWR4KTtcbiAgICB3aGlsZSAoIWlzRU9TKGNoYXIpKSB7XG4gICAgICBsZXQgaGV4ID0gZ2V0SGV4VmFsdWUoY2hhcik7XG4gICAgICBpZiAoaGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICBoZXhEaWdpdHMgPSAoaGV4RGlnaXRzIDw8IDQpIHwgaGV4O1xuICAgICAgaWYgKGhleERpZ2l0cyA+IDB4MTBGRkZGKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICAgIH1cbiAgICAgIGNoYXIgPSBzUGVlaygrK2lkeCk7XG4gICAgfVxuICAgIGlmIChjaGFyICE9PSAnfScpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICB9XG4gICAgaWYgKGlkeCA9PT0gc3RhcnQgKyAxKSB7XG4gICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoc3RyZWFtLnBlZWsoaWR4KzEpKTtcbiAgICB9XG4gICAgKytpZHg7XG4gIH0gZWxzZSB7XG4gICAgLy9cXHVIZXg0RGlnaXRzXG4gICAgaWYgKGlzRU9TKHNQZWVrKGlkeCArIDMpKSkgcmV0dXJuIC0xO1xuICAgIGxldCByO1xuICAgIGZvciAoOyBpZHggPCBzdGFydCArIDQ7ICsraWR4KSB7XG4gICAgICByID0gZ2V0SGV4VmFsdWUoc1BlZWsoaWR4KSk7XG4gICAgICBpZiAociA9PT0gLTEpIHJldHVybiAtMTtcbiAgICAgIGhleERpZ2l0cyA9IChoZXhEaWdpdHMgPDwgNCkgfCByO1xuICAgIH1cbiAgfVxuICBzdHJlYW0ucmVhZFN0cmluZyhpZHgpO1xuXG4gIHJldHVybiBoZXhEaWdpdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nRXNjYXBlKHN0cjogc3RyaW5nLCBzdHJlYW06IENoYXJTdHJlYW0sIHN0YXJ0OiBudW1iZXIsIG9jdGFsOiA/c3RyaW5nKSB7XG4gIGxldCBpZHggPSBzdGFydCArIDEsXG4gICAgICBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KSxcbiAgICAgIGxpbmVTdGFydDtcbiAgaWYgKGlzRU9TKGNoYXIpKSB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG5cbiAgaWYgKCFpc0xpbmVUZXJtaW5hdG9yKGNoYXIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgJ2InOiBzdHIgKz0gJ1xcYic7ICsraWR4OyBicmVhaztcbiAgICAgIGNhc2UgJ2YnOiBzdHIgKz0gJ1xcZic7ICsraWR4OyBicmVhaztcbiAgICAgIGNhc2UgJ24nOiBzdHIgKz0gJ1xcbic7ICsraWR4OyBicmVhaztcbiAgICAgIGNhc2UgJ3InOiBzdHIgKz0gJ1xccic7ICsraWR4OyBicmVhaztcbiAgICAgIGNhc2UgJ3QnOiBzdHIgKz0gJ1xcdCc7ICsraWR4OyBicmVhaztcbiAgICAgIGNhc2UgJ3YnOiBzdHIgKz0gJ1xcdTAwMEInOyArK2lkeDsgYnJlYWs7XG4gICAgICBjYXNlICd1JzpcbiAgICAgIGNhc2UgJ3gnOiB7XG4gICAgICAgIGxldCB1bmVzY2FwZWQ7XG4gICAgICAgICsraWR4O1xuICAgICAgICBsZXQgbnh0ID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgICAgICAgaWYgKGlzRU9TKG54dCkpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwobnh0KTtcbiAgICAgICAgfVxuICAgICAgICB1bmVzY2FwZWQgPSBjaGFyID09PSAndScgPyBzY2FuVW5pY29kZS5jYWxsKHRoaXMsIHN0cmVhbSwgaWR4KSA6IHNjYW5IZXhFc2NhcGUyLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gLTEpIHRocm93IHRoaXMuY3JlYXRlSUxMRUdBTChjaGFyKTtcbiAgICAgICAgaWR4ID0gMDsgLy8gc3RyZWFtIGlzIHJlYWQgaW4gc2NhblVuaWNvZGUgYW5kIHNjYW5IZXhFc2NhcGUyXG5cbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHVuZXNjYXBlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnNycpIHtcbiAgICAgICAgICBbc3RyLCBpZHgsIG9jdGFsXSA9IHNjYW5PY3RhbC5jYWxsKHRoaXMsIHN0ciwgc3RyZWFtLCBjaGFyLCBpZHgsIG9jdGFsKTtcbiAgICAgICAgfSBlbHNlIGlmKGNoYXIgPT09ICc4JyB8fCBjaGFyID09PSAnOScpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoY2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9IGNoYXI7XG4gICAgICAgICAgKytpZHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNoYXIgPT09ICdcXHInICYmIHN0cmVhbS5wZWVrKGlkeCArIDEpID09PSAnXFxuJykge1xuICAgICAgKytpZHg7XG4gICAgfVxuICAgICsraWR4O1xuICAgIHRoaXMuaW5jcmVtZW50TGluZSgpO1xuICAgIGxpbmVTdGFydCA9IGlkeDtcbiAgfVxuICByZXR1cm4gW3N0ciwgaWR4LCBvY3RhbCwgbGluZVN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gc2Nhbk9jdGFsKHN0ciwgc3RyZWFtLCBjaGFyLCBzdGFydCwgb2N0YWwpIHtcbiAgbGV0IGxlbiA9IDEsIGlkeCA9IHN0YXJ0O1xuICBpZiAoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnMycpIHtcbiAgICBsZW4gPSAwO1xuICB9XG4gIGxldCBjb2RlID0gMDtcblxuICB3aGlsZSAobGVuIDwgMyAmJiAnMCcgPD0gY2hhciAmJiBjaGFyIDw9ICc3Jykge1xuICAgICsraWR4O1xuICAgIGlmIChsZW4gPiAwIHx8IGNoYXIgIT09ICcwJykge1xuICAgICAgaWYgKG9jdGFsID09IG51bGwpIG9jdGFsID0gJyc7XG4gICAgICBvY3RhbCArPSBjaGFyO1xuICAgIH1cbiAgICBjb2RlICo9IDg7XG4gICAgY29kZSArPSArY2hhcjsgLy9jb2Vyc2lvblxuICAgICsrbGVuO1xuICAgIGNoYXIgPSBzdHJlYW0ucGVlayhpZHgpO1xuICAgIGlmIChpc0VPUyhjaGFyKSkge1xuICAgICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKGNoYXIpO1xuICAgIH1cbiAgfVxuICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgcmV0dXJuIFtzdHIsIGlkeCwgb2N0YWxdO1xufVxuXG5mdW5jdGlvbiBzY2FuSGV4RXNjYXBlMihzdHJlYW0sIGlkeCkge1xuICBsZXQgY2hhciA9IHN0cmVhbS5wZWVrKGlkeCk7XG5cbiAgaWYgKGlzRU9TKGNoYXIpKSByZXR1cm4gLTE7XG5cbiAgbGV0IHIxID0gZ2V0SGV4VmFsdWUoc3RyZWFtLnBlZWsoKSk7XG4gIGlmIChyMSA9PT0gLTEpIHJldHVybiByMTtcblxuICBsZXQgcjIgPSBnZXRIZXhWYWx1ZShzdHJlYW0ucGVlaygxKSk7XG4gIGlmIChyMiA9PT0gLTEpIHJldHVybiByMjtcblxuICBzdHJlYW0ucmVhZFN0cmluZygyKTtcbiAgcmV0dXJuIHIxIDw8IDQgfCByMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFNlcXVlbmNlKGNvbGw6IE9iamVjdCwgc2VxOiBzdHJpbmcpIHtcbiAgY29uc3QgY2hhciA9IHNlcVswXTtcbiAgaWYgKCFjb2xsW2NoYXJdKSB7XG4gICAgY29sbFtjaGFyXSA9IHt9O1xuICB9XG4gIGlmIChzZXEubGVuZ3RoID09PSAxKSB7XG4gICAgY29sbFtjaGFyXS5pc1ZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gY29sbDtcbiAgfSBlbHNlIHtcbiAgICBjb2xsW2NoYXJdID0gaW5zZXJ0U2VxdWVuY2UoY29sbFtjaGFyXSwgc2VxLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gY29sbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaXNUZXJtaW5hdGluZyA9ICh0YWJsZTogUmVhZHRhYmxlKSA9PiAoY2hhcjogc3RyaW5nKTogYm9vbGVhbiA9PiB0YWJsZS5nZXRNYXBwaW5nKGNoYXIpLm1vZGUgPT09ICd0ZXJtaW5hdGluZyc7XG5cbi8vIGNoZWNrIGZvciB0ZXJtaW5hdGluZyBkb2Vzbid0IHdvcmsgaWYgaXQncyBhdCB0aGUgc3RhcnRcbmV4cG9ydCBmdW5jdGlvbiByZXRyaWV2ZVNlcXVlbmNlTGVuZ3RoKHRhYmxlOiBPYmplY3QsIHN0cmVhbTogQ2hhclN0cmVhbSwgaWR4OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBjaGFyID0gc3RyZWFtLnBlZWsoaWR4KTtcbiAgaWYgKCF0YWJsZVtjaGFyXSkge1xuICAgIGlmICh0YWJsZS5pc1ZhbHVlKSByZXR1cm4gaWR4O1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0cmlldmVTZXF1ZW5jZUxlbmd0aCh0YWJsZVtjaGFyXSwgc3RyZWFtLCArK2lkeCk7XG4gIH1cbn1cblxuLy8gY29uc3QgaXNFT1MgPSBSLndoZXJlRXEoeyB0eXBlOiBUb2tlblR5cGUuRU9TIH0pO1xuXG4vLyBjb25zdCBpc0hhc2ggPSBSLndoZXJlRXEoeyB0eXBlOiBUb2tlblR5cGUuSURFTlRJRklFUiwgdmFsdWU6ICcjJ30pO1xuXG5jb25zdCBhc3NpZ25PcHMgPSAgWyc9JywgJys9JywgJy09JywgJyo9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCddO1xuXG5jb25zdCBiaW5hcnlPcHMgPSBbJysnLCAnLScsICcqJywgJy8nLCAnJScsJzw8JywgJz4+JywgJz4+PicsICcmJywgJ3wnLCAnXicsXG4gICAgICAgICAgICAgICAgICcmJicsICd8fCcsICc/JywgJzonLFxuICAgICAgICAgICAgICAgICAnPT09JywgJz09JywgJz49JywgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nLCAnaW5zdGFuY2VvZiddO1xuXG5jb25zdCB1bmFyeU9wcyA9IFsnKysnLCAnLS0nLCAnficsICchJywgJ2RlbGV0ZScsICd2b2lkJywgJ3R5cGVvZicsICd5aWVsZCcsICd0aHJvdycsICduZXcnXTtcblxuLy8gTGlzdCAtPiBCb29sZWFuXG5jb25zdCBpc0VtcHR5ID0gUi53aGVyZUVxKHtzaXplOiAwfSk7XG5cbi8vIFN5bnRheCAtPiBCb29sZWFuXG5jb25zdCBpc1B1bmN0dWF0b3IgPSBzID0+IHMubWF0Y2goJ3B1bmN0dWF0b3InKTtcbmNvbnN0IGlzS2V5d29yZCA9IHMgPT4gcy5tYXRjaCgna2V5d29yZCcpO1xuY29uc3QgaXNQYXJlbnMgPSBzID0+IHMubWF0Y2goJ3BhcmVucycpO1xuY29uc3QgaXNCcmFjZXMgPSBzID0+IHMubWF0Y2goJ2JyYWNlcycpO1xuY29uc3QgaXNJZGVudGlmaWVyID0gcyA9PiBzLm1hdGNoKCdpZGVudGlmaWVyJyk7XG5cbi8vIEFueSAtPiBTeW50YXggLT4gQm9vbGVhblxuY29uc3QgaXNWYWwgPSBSLmN1cnJ5KCh2LCBzKSA9PiBzLnZhbCgpID09PSB2KTtcblxuLy8gU3ludGF4IC0+IEJvb2xlYW5cbmNvbnN0IGlzRG90ID0gUi5hbGxQYXNzKFtpc1B1bmN0dWF0b3IsIGlzVmFsKCcuJyldKTtcbmNvbnN0IGlzQ29sb24gPSBSLmFsbFBhc3MoW2lzUHVuY3R1YXRvciwgaXNWYWwoJzonKV0pO1xuY29uc3QgaXNGdW5jdGlvbktleXdvcmQgPSBSLmFsbFBhc3MoW2lzS2V5d29yZCwgaXNWYWwoJ2Z1bmN0aW9uJyldKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSBzID0+IChzLm1hdGNoKCdwdW5jdHVhdG9yJykgfHwgcy5tYXRjaCgna2V5d29yZCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBSLmFueShSLmVxdWFscyhzLnZhbCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduT3BzLmNvbmNhdChiaW5hcnlPcHMpLmNvbmNhdCh1bmFyeU9wcykpO1xuY29uc3QgaXNOb25MaXRlcmFsS2V5d29yZCA9IFIuYWxsUGFzcyhbaXNLZXl3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9PiBSLm5vbmUoUi5lcXVhbHMocy52YWwoKSksIGxpdGVyYWxLZXl3b3JkcyldKTtcbmNvbnN0IGlzS2V5d29yZEV4cHJQcmVmaXggPSBSLmFsbFBhc3MoW2lzS2V5d29yZCxcbiAgcyA9PiBSLmFueShSLmVxdWFscyhzLnZhbCgpKSwgWydpbnN0YW5jZW9mJywgJ3R5cGVvZicsICdkZWxldGUnLCAndm9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3lpZWxkJywgJ3Rocm93JywgJ25ldycsICdjYXNlJ10pXSk7XG4vLyBMaXN0IGEgLT4gYT9cbmxldCBsYXN0ID0gcCA9PiBwLmxhc3QoKTtcbi8vIExpc3QgYSAtPiBNYXliZSBhXG5sZXQgc2FmZUxhc3QgPSBSLnBpcGUoUi5jb25kKFtcbiAgW2lzRW1wdHksIFIuYWx3YXlzKE5vdGhpbmcoKSldLFxuICBbUi5ULCBSLmNvbXBvc2UoTWF5YmUub2YsIGxhc3QpXVxuXSkpO1xuXG4vLyBUT0RPOiBiZXR0ZXIgbmFtZSAoYXJlVHJ1ZSAmIGFyZUZhbHNlKT9cbi8vIExpc3QgLT4gQm9vbGVhbiAtPiBNYXliZSBMaXN0XG5sZXQgc3R1ZmZUcnVlID0gUi5jdXJyeSgocCwgYikgPT4gYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xubGV0IHN0dWZmRmFsc2UgPSBSLmN1cnJ5KChwLCBiKSA9PiAhYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xuXG4vLyBMaXN0IGEgLT4gQm9vbGVhblxubGV0IGlzVG9wQ29sb24gPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc0NvbG9uKSxcbiAgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpXG4pO1xuLy8gTGlzdCBhIC0+IEJvb2xlYW5cbmxldCBpc1RvcFB1bmN0dWF0b3IgPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc1B1bmN0dWF0b3IpLFxuICBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSlcbik7XG5cbi8vIE51bWJlciAtPiBMaXN0IC0+IEJvb2xlYW5cbmxldCBpc0V4cHJSZXR1cm4gPSBSLmN1cnJ5KChsLCBwKSA9PiB7XG4gIGxldCByZXRLd2QgPSBzYWZlTGFzdChwKTtcbiAgbGV0IG1heWJlRG90ID0gcG9wKHApLmNoYWluKHNhZmVMYXN0KTtcblxuICBpZiAobWF5YmVEb3QubWFwKGlzRG90KS5nZXRPckVsc2UoZmFsc2UpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldEt3ZC5tYXAocyA9PiB7XG4gICAgcmV0dXJuIHMubWF0Y2goJ2tleXdvcmQnKSAmJiBzLnZhbCgpID09PSAncmV0dXJuJyAmJiBzLmxpbmVOdW1iZXIoKSA9PT0gbDtcbiAgfSkuZ2V0T3JFbHNlKGZhbHNlKTtcbn0pO1xuXG5jb25zdCBpc1RvcE9wZXJhdG9yID0gUi5waXBlKFxuICBzYWZlTGFzdCxcbiAgUi5tYXAoaXNPcGVyYXRvciksXG4gIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KVxuKTtcblxuY29uc3QgaXNUb3BLZXl3b3JkRXhwclByZWZpeCA9IFIucGlwZShcbiAgc2FmZUxhc3QsXG4gIFIubWFwKGlzS2V5d29yZEV4cHJQcmVmaXgpLFxuICBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSlcbik7XG5cbi8vIE51bWJlciAtPiBCb29sZWFuIC0+IExpc3QgLT4gQm9vbGVhblxuZXhwb3J0IGxldCBpc0V4cHJQcmVmaXggPSBSLmN1cnJ5KChsLCBiKSA9PiBSLmNvbmQoW1xuICAvLyAuLi4gKHt4OiA0Mn0gL3IvaSlcbiAgW2lzRW1wdHksIFIuYWx3YXlzKGIpXSxcbiAgLy8gLi4uICh7eDoge3g6IDQyfSAvci9pIH0pXG4gIFtpc1RvcENvbG9uLCBSLmFsd2F5cyhiKV0sXG4gIC8vIC4uLiB0aHJvdyB7eDogNDJ9IC9yL2lcbiAgW2lzVG9wS2V5d29yZEV4cHJQcmVmaXgsIFIuVF0sXG4gIC8vIC4uLiA0MiArIHt4OiA0Mn0gL3IvaVxuICBbaXNUb3BPcGVyYXRvciwgUi5UXSxcbiAgLy8gLi4uIGZvciAoIDsge3g6IDQyfS9yL2kpXG4gIFtpc1RvcFB1bmN0dWF0b3IsIFIuYWx3YXlzKGIpXSxcbiAgLy8gLi4uIHJldHVybiB7eDogNDJ9IC9yIC9pXG4gIC8vIC4uLiByZXR1cm5cXG57eDogNDJ9IC9yIC9pXG4gIFtpc0V4cHJSZXR1cm4obCksIFIuVF0sXG4gIFtSLlQsIFIuRl0sXG5dKSk7XG5cbi8vIExpc3QgYSAtPiBNYXliZSBMaXN0IGFcbmxldCBjdXJseSA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzQnJhY2VzKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IHBhcmVuID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNQYXJlbnMpLmNoYWluKHN0dWZmVHJ1ZShwKSk7XG5sZXQgZnVuYyA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzRnVuY3Rpb25LZXl3b3JkKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IGlkZW50ID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNJZGVudGlmaWVyKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IG5vbkxpdGVyYWxLZXl3b3JkID0gcCA9PiBzYWZlTGFzdChwKS5tYXAoaXNOb25MaXRlcmFsS2V5d29yZCkuY2hhaW4oc3R1ZmZUcnVlKHApKTtcblxubGV0IG9wdCA9IFIuY3VycnkoKGEsIGIsIHApID0+IHtcbiAgbGV0IHJlc3VsdCA9IFIucGlwZUsoYSwgYikoTWF5YmUub2YocCkpO1xuICByZXR1cm4gTWF5YmUuaXNKdXN0KHJlc3VsdCkgPyByZXN1bHQgOiBNYXliZS5vZihwKTtcbn0pO1xuXG5sZXQgbm90RG90ID0gUi5pZkVsc2UoXG4gIFIud2hlcmVFcSh7c2l6ZTogMH0pLFxuICBKdXN0LFxuICBwID0+IHNhZmVMYXN0KHApLm1hcChzID0+ICEocy5tYXRjaCgncHVuY3R1YXRvcicpICYmIHMudmFsKCkgPT09ICcuJykpLmNoYWluKHN0dWZmVHJ1ZShwKSlcbik7XG5cbi8vIExpc3QgYSAtPiBNYXliZSBMaXN0IGFcbmxldCBwb3AgPSBSLmNvbXBvc2UoSnVzdCwgcCA9PiBwLnBvcCgpKTtcblxuLy8gTWF5YmUgTGlzdCBhIC0+IE1heWJlIExpc3QgYVxuY29uc3QgZnVuY3Rpb25QcmVmaXggPSBSLnBpcGVLKFxuICAgIGN1cmx5LFxuICAgIHBvcCxcbiAgICBwYXJlbixcbiAgICBwb3AsXG4gICAgb3B0KGlkZW50LCBwb3ApLFxuICAgIGZ1bmMpO1xuXG4vLyBCb29sZWFuIC0+IExpc3QgYSAtPiBCb29sZWFuXG5leHBvcnQgY29uc3QgaXNSZWdleFByZWZpeCA9IChleHByQWxsb3dlZDogYm9vbGVhbikgPT4gUi5hbnlQYXNzKFtcbiAgLy8gzrVcbiAgaXNFbXB0eSxcbiAgLy8gUCAuIHQgICB3aGVyZSB0IOKIiCBQdW5jdHVhdG9yXG4gIGlzVG9wUHVuY3R1YXRvcixcbiAgLy8gUCAuIHQgLiB0JyAgd2hlcmUgdCBcXG5vdCA9IFwiLlwiIGFuZCB0JyDiiIggKEtleXdvcmQgXFxzZXRtaW51cyAgTGl0ZXJhbEtleXdvcmQpXG4gIFIucGlwZShcbiAgICBNYXliZS5vZixcbiAgICBSLnBpcGVLKFxuICAgICAgbm9uTGl0ZXJhbEtleXdvcmQsXG4gICAgICBwb3AsXG4gICAgICBub3REb3RcbiAgICApLFxuICAgIE1heWJlLmlzSnVzdFxuICApLFxuICAvLyBQIC4gdCAuIHQnIC4gKFQpICB3aGVyZSB0IFxcbm90ID0gXCIuXCIgYW5kIHQnIOKIiCAoS2V5d29yZCBcXHNldG1pbnVzIExpdGVyYWxLZXl3b3JkKVxuICBSLnBpcGUoXG4gICAgTWF5YmUub2YsXG4gICAgUi5waXBlSyhcbiAgICAgIHBhcmVuLFxuICAgICAgcG9wLFxuICAgICAgbm9uTGl0ZXJhbEtleXdvcmQsXG4gICAgICBwb3AsXG4gICAgICBub3REb3RcbiAgICApLFxuICAgIE1heWJlLmlzSnVzdFxuICApLFxuICAvLyBQIC4gZnVuY3Rpb25ebCAuIHg/IC4gKCkgLiB7fSAgICAgd2hlcmUgaXNFeHByUHJlZml4KFAsIGIsIGwpID0gZmFsc2VcbiAgUi5waXBlKFxuICAgIE1heWJlLm9mLFxuICAgIGZ1bmN0aW9uUHJlZml4LFxuICAgIFIuY2hhaW4ocCA9PiB7XG4gICAgICAgIHJldHVybiBzYWZlTGFzdChwKVxuICAgICAgICAgIC5tYXAocyA9PiBzLmxpbmVOdW1iZXIoKSlcbiAgICAgICAgICAuY2hhaW4oZm5MaW5lID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwb3AocCkubWFwKGlzRXhwclByZWZpeChmbkxpbmUsIGV4cHJBbGxvd2VkKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2hhaW4oc3R1ZmZGYWxzZShwKSk7XG4gICAgICB9XG4gICAgKSxcbiAgICBNYXliZS5pc0p1c3RcbiAgKSxcbiAgLy8gUCAuIHtUfV5sICB3aGVyZSBpc0V4cHJQcmVmaXgoUCwgYiwgbCkgPSBmYWxzZVxuICBwID0+IHtcbiAgICBsZXQgYWxyZWFkeUNoZWNrZWRGdW5jdGlvbiA9IFIucGlwZShcbiAgICAgIE1heWJlLm9mLFxuICAgICAgZnVuY3Rpb25QcmVmaXgsXG4gICAgICBNYXliZS5pc0p1c3RcbiAgICApKHApO1xuICAgIGlmIChhbHJlYWR5Q2hlY2tlZEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBSLnBpcGUoXG4gICAgICBNYXliZS5vZixcbiAgICAgIFIuY2hhaW4oY3VybHkpLFxuICAgICAgUi5jaGFpbihwID0+IHtcbiAgICAgICAgcmV0dXJuIHNhZmVMYXN0KHApXG4gICAgICAgIC5tYXAocyA9PiBzLmxpbmVOdW1iZXIoKSlcbiAgICAgICAgLmNoYWluKGN1cmx5TGluZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBvcChwKS5tYXAoaXNFeHByUHJlZml4KGN1cmx5TGluZSwgZXhwckFsbG93ZWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNoYWluKHN0dWZmRmFsc2UocCkpO1xuICAgICAgfSksXG4gICAgICBNYXliZS5pc0p1c3RcbiAgICApKHApO1xuICB9XG5cblxuXSk7XG4iXX0=