'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readSyntaxTemplate = readSyntaxTemplate;

var _readtable = require('readtable');

var _immutable = require('immutable');

var _tokens = require('../tokens');

const backtickEntry = {
  key: '`',
  mode: 'terminating',
  action: function readBacktick(stream, prefix, e) {
    if (prefix.isEmpty()) {
      return {
        type: _tokens.TokenType.LSYNTAX,
        value: stream.readString()
      };
    }

    return {
      type: _tokens.TokenType.RSYNTAX,
      value: stream.readString()
    };
  }
};

function readSyntaxTemplate(stream, prefix, exprAllowed, dispatchChar) {
  // return read('syntaxTemplate').first().token;
  // TODO: Can we simply tack 'syntaxTemplate' on the front and process it as a
  //       syntax macro?
  const prevTable = (0, _readtable.getCurrentReadtable)();
  (0, _readtable.setCurrentReadtable)(prevTable.extend(backtickEntry));

  const result = this.readUntil('`', stream, _immutable.List.of(updateSyntax(dispatchChar, this.readToken(stream, (0, _immutable.List)(), exprAllowed))), exprAllowed);

  (0, _readtable.setCurrentReadtable)(prevTable);
  return result;
}

function updateSyntax(prefix, token) {
  token.value = prefix + token.value;
  token.slice.text = prefix + token.slice.text;
  token.slice.start -= 1;
  token.slice.startLocation.position -= 1;
  return token;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFkZXIvcmVhZC1kaXNwYXRjaC5qcyJdLCJuYW1lcyI6WyJyZWFkU3ludGF4VGVtcGxhdGUiLCJiYWNrdGlja0VudHJ5Iiwia2V5IiwibW9kZSIsImFjdGlvbiIsInJlYWRCYWNrdGljayIsInN0cmVhbSIsInByZWZpeCIsImUiLCJpc0VtcHR5IiwidHlwZSIsIkxTWU5UQVgiLCJ2YWx1ZSIsInJlYWRTdHJpbmciLCJSU1lOVEFYIiwiZXhwckFsbG93ZWQiLCJkaXNwYXRjaENoYXIiLCJwcmV2VGFibGUiLCJleHRlbmQiLCJyZXN1bHQiLCJyZWFkVW50aWwiLCJvZiIsInVwZGF0ZVN5bnRheCIsInJlYWRUb2tlbiIsInRva2VuIiwic2xpY2UiLCJ0ZXh0Iiwic3RhcnQiLCJzdGFydExvY2F0aW9uIiwicG9zaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7O1FBMEJnQkEsa0IsR0FBQUEsa0I7O0FBeEJoQjs7QUFDQTs7QUFDQTs7QUFJQSxNQUFNQyxnQkFBZ0I7QUFDcEJDLE9BQUssR0FEZTtBQUVwQkMsUUFBTSxhQUZjO0FBR3BCQyxVQUFRLFNBQVNDLFlBQVQsQ0FBc0JDLE1BQXRCLEVBQTBDQyxNQUExQyxFQUE2REMsQ0FBN0QsRUFBeUU7QUFDL0UsUUFBSUQsT0FBT0UsT0FBUCxFQUFKLEVBQXNCO0FBQ3BCLGFBQU87QUFDTEMsY0FBTSxrQkFBR0MsT0FESjtBQUVMQyxlQUFPTixPQUFPTyxVQUFQO0FBRkYsT0FBUDtBQUlEOztBQUVELFdBQU87QUFDTEgsWUFBTSxrQkFBR0ksT0FESjtBQUVMRixhQUFPTixPQUFPTyxVQUFQO0FBRkYsS0FBUDtBQUlEO0FBZm1CLENBQXRCOztBQWtCTyxTQUFTYixrQkFBVCxDQUE0Qk0sTUFBNUIsRUFBZ0RDLE1BQWhELEVBQW1FUSxXQUFuRSxFQUF5RkMsWUFBekYsRUFBdUs7QUFDNUs7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsWUFBWSxxQ0FBbEI7QUFDQSxzQ0FBb0JBLFVBQVVDLE1BQVYsQ0FBaUJqQixhQUFqQixDQUFwQjs7QUFFQSxRQUFNa0IsU0FBUyxLQUFLQyxTQUFMLENBQ2IsR0FEYSxFQUViZCxNQUZhLEVBR2IsZ0JBQUtlLEVBQUwsQ0FBUUMsYUFBYU4sWUFBYixFQUEyQixLQUFLTyxTQUFMLENBQWVqQixNQUFmLEVBQXVCLHNCQUF2QixFQUErQlMsV0FBL0IsQ0FBM0IsQ0FBUixDQUhhLEVBSWJBLFdBSmEsQ0FBZjs7QUFNQSxzQ0FBb0JFLFNBQXBCO0FBQ0EsU0FBT0UsTUFBUDtBQUNEOztBQUVELFNBQVNHLFlBQVQsQ0FBc0JmLE1BQXRCLEVBQThCaUIsS0FBOUIsRUFBcUM7QUFDbkNBLFFBQU1aLEtBQU4sR0FBY0wsU0FBU2lCLE1BQU1aLEtBQTdCO0FBQ0FZLFFBQU1DLEtBQU4sQ0FBWUMsSUFBWixHQUFtQm5CLFNBQVNpQixNQUFNQyxLQUFOLENBQVlDLElBQXhDO0FBQ0FGLFFBQU1DLEtBQU4sQ0FBWUUsS0FBWixJQUFxQixDQUFyQjtBQUNBSCxRQUFNQyxLQUFOLENBQVlHLGFBQVosQ0FBMEJDLFFBQTFCLElBQXNDLENBQXRDO0FBQ0EsU0FBT0wsS0FBUDtBQUNEIiwiZmlsZSI6InJlYWQtZGlzcGF0Y2guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRDdXJyZW50UmVhZHRhYmxlLCBzZXRDdXJyZW50UmVhZHRhYmxlIH0gZnJvbSAncmVhZHRhYmxlJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IHsgVG9rZW5UeXBlIGFzIFRUIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuaW1wb3J0IHR5cGUgeyBDaGFyU3RyZWFtIH0gZnJvbSAncmVhZHRhYmxlJztcblxuY29uc3QgYmFja3RpY2tFbnRyeSA9IHtcbiAga2V5OiAnYCcsXG4gIG1vZGU6ICd0ZXJtaW5hdGluZycsXG4gIGFjdGlvbjogZnVuY3Rpb24gcmVhZEJhY2t0aWNrKHN0cmVhbTogQ2hhclN0cmVhbSwgcHJlZml4OiBMaXN0PGFueT4sIGU6IGJvb2xlYW4pIHtcbiAgICBpZiAocHJlZml4LmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVFQuTFNZTlRBWCxcbiAgICAgICAgdmFsdWU6IHN0cmVhbS5yZWFkU3RyaW5nKClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRULlJTWU5UQVgsXG4gICAgICB2YWx1ZTogc3RyZWFtLnJlYWRTdHJpbmcoKVxuICAgIH07XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3ludGF4VGVtcGxhdGUoc3RyZWFtOiBDaGFyU3RyZWFtLCBwcmVmaXg6IExpc3Q8YW55PiwgZXhwckFsbG93ZWQ6IGJvb2xlYW4sIGRpc3BhdGNoQ2hhcjogc3RyaW5nKTogTGlzdDxhbnk+IHwgeyB0eXBlOiB0eXBlb2YgVFQuUlNZTlRBWCwgdmFsdWU6IHN0cmluZyB9IHtcbiAgLy8gcmV0dXJuIHJlYWQoJ3N5bnRheFRlbXBsYXRlJykuZmlyc3QoKS50b2tlbjtcbiAgLy8gVE9ETzogQ2FuIHdlIHNpbXBseSB0YWNrICdzeW50YXhUZW1wbGF0ZScgb24gdGhlIGZyb250IGFuZCBwcm9jZXNzIGl0IGFzIGFcbiAgLy8gICAgICAgc3ludGF4IG1hY3JvP1xuICBjb25zdCBwcmV2VGFibGUgPSBnZXRDdXJyZW50UmVhZHRhYmxlKCk7XG4gIHNldEN1cnJlbnRSZWFkdGFibGUocHJldlRhYmxlLmV4dGVuZChiYWNrdGlja0VudHJ5KSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWFkVW50aWwoXG4gICAgJ2AnLFxuICAgIHN0cmVhbSxcbiAgICBMaXN0Lm9mKHVwZGF0ZVN5bnRheChkaXNwYXRjaENoYXIsIHRoaXMucmVhZFRva2VuKHN0cmVhbSwgTGlzdCgpLCBleHByQWxsb3dlZCkpKSxcbiAgICBleHByQWxsb3dlZCk7XG5cbiAgc2V0Q3VycmVudFJlYWR0YWJsZShwcmV2VGFibGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW50YXgocHJlZml4LCB0b2tlbikge1xuICB0b2tlbi52YWx1ZSA9IHByZWZpeCArIHRva2VuLnZhbHVlO1xuICB0b2tlbi5zbGljZS50ZXh0ID0gcHJlZml4ICsgdG9rZW4uc2xpY2UudGV4dDtcbiAgdG9rZW4uc2xpY2Uuc3RhcnQgLT0gMTtcbiAgdG9rZW4uc2xpY2Uuc3RhcnRMb2NhdGlvbi5wb3NpdGlvbiAtPSAxO1xuICByZXR1cm4gdG9rZW47XG59XG4iXX0=